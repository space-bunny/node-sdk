{"version":3,"sources":["spacebunny.js"],"names":["require","CONFIG","SpaceBunny","opts","_connectionParams","humps","camelizeKeys","_endpointConfigs","undefined","_endpoint","endpoint","_deviceKey","deviceKey","_channels","channels","_deviceId","deviceId","_client","client","_secret","secret","_host","host","_port","port","_vhost","vhost","_protocol","protocol","_inboxTopic","inputTopic","inboxTopic","_liveStreamSuffix","liveStreamSuffix","_tempQueueSuffix","tempQueueSuffix","_liveStreams","_tls","tls","_tlsOpts","cert","fs","readFileSync","key","passphrase","ca","Array","isArray","map","element","pfx","disableCertCheck","rejectUnauthorized","secureProtocol","Promise","resolve","reject","hostname","_generateHostname","uri","url","deviceConfigurationsPath","options","method","responseType","headers","then","response","data","connection","catch","err","protocols","tlsPort","liveStreams","liveStreamKeyConfigurationsPath","Error","obj","name","streamName","stream","length","id","prefix","suffix","currentTime","timestamp","Date","getTime","exchangeName","liveStreamByName","content","encapsulatedContent","JSON","stringify","ex","message","parsedMessage","Buffer","isBuffer","toString","res","parse","EventEmitter"],"mappings":"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","file":"spacebunny.js","sourcesContent":["/**\n * A module that exports the base SpaceBunny client\n * @module SpaceBunny\n */\n\n// Import some helpers modules\nimport fs from 'fs';\nimport merge from 'merge';\nimport axios from 'axios';\nimport humps from 'humps';\nimport Promise from 'bluebird';\nimport { startsWith, filter } from 'lodash';\nimport url from 'url';\nimport EventEmitter from 'events';\n\n// TODO validate enpointConfig object format with Joi\n// import Joi from 'joi';\n\nconst { CONFIG } = require('../config/constants');\n\n/**\n * @constructor\n * @param {Object} opts - constructor options may contain Device-Key or connection options\n */\nclass SpaceBunny extends EventEmitter {\n  constructor(opts = {}) {\n    super();\n    this._connectionParams = merge({}, humps.camelizeKeys(opts));\n    this._endpointConfigs = undefined;\n    this._endpoint = merge(CONFIG.endpoint, this._connectionParams.endpoint);\n    this._deviceKey = this._connectionParams.deviceKey;\n    this._channels = this._connectionParams.channels;\n    this._deviceId = this._connectionParams.deviceId;\n    this._client = this._connectionParams.client;\n    this._secret = this._connectionParams.secret;\n    this._host = this._connectionParams.host;\n    this._port = this._connectionParams.port;\n    this._vhost = this._connectionParams.vhost;\n    this._protocol = CONFIG.protocol;\n    this._inboxTopic = this._connectionParams.inputTopic || CONFIG.inboxTopic;\n    this._liveStreamSuffix = CONFIG.liveStreamSuffix;\n    this._tempQueueSuffix = CONFIG.tempQueueSuffix;\n    this._liveStreams = [];\n    this._tls = this._connectionParams.tls || false;\n    this._tlsOpts = {};\n    if (this._connectionParams.cert) { this._tlsOpts.cert = fs.readFileSync(this._connectionParams.cert); }\n    if (this._connectionParams.key) { this._tlsOpts.key = fs.readFileSync(this._connectionParams.key); }\n    if (this._connectionParams.passphrase) { this._tlsOpts.passphrase = this._connectionParams.passphrase; }\n    if (this._connectionParams.ca) {\n      if (Array.isArray(this._connectionParams.ca)) {\n        this._tlsOpts.ca = this._connectionParams.ca.map((element) => {\n          return fs.readFileSync(element);\n        });\n      } else {\n        this._tlsOpts.ca = [fs.readFileSync(this._connectionParams.ca)];\n      }\n    }\n    if (this._connectionParams.pfx) { this._tlsOpts.pfx = fs.readFileSync(this._connectionParams.pfx); }\n    if (this._connectionParams.disableCertCheck) {\n      this._tlsOpts.rejectUnauthorized = false;\n    } else {\n      this._tlsOpts.rejectUnauthorized = true;\n    }\n    this._tlsOpts.secureProtocol = this._connectionParams.secureProtocol || CONFIG.tls.secureProtocol;\n  }\n\n  /**\n   * Check if Device-Key or connection parameters have already been passed\n   * If at least Device-Key is passed ask the endpoint for the configurations\n   * else if also connection parameters are not passed raise an exception\n   *\n   * @return an Object containing the connection parameters\n   */\n  getEndpointConfigs() {\n    return new Promise((resolve, reject) => {\n      // Resolve with configs if already retrieved\n      if (this._endpointConfigs !== undefined) {\n        resolve(this._endpointConfigs);\n      }\n      // Contact endpoint to retrieve configs\n      // Switch endpoint if you are using sdk as device or as access key stream\n      if ((this._deviceId && this._secret) || this._deviceKey) { // Device credentials\n        // uses endpoint passed from user, default endpoint otherwise\n        const hostname = this._generateHostname();\n        const uri = url.resolve(hostname, this._endpoint.deviceConfigurationsPath);\n        if (this._deviceKey) { // Get configs from endpoint\n          const options = {\n            url: uri,\n            method: 'get',\n            responseType: 'json',\n            headers: {\n              'Device-Key': this._deviceKey,\n              'Content-Type': 'application/json'\n            }\n          };\n          axios(options).then((response) => {\n            this._endpointConfigs = humps.camelizeKeys(response.data);\n            this._connectionParams = this._endpointConfigs.connection;\n            resolve(this._endpointConfigs);\n          }).catch((err) => {\n            reject(err);\n          });\n        } else if (this._deviceId && this._secret && this._host && this._port && this._vhost) {\n          // Manually provided configs\n          this._connectionParams.protocols = {};\n          if (this._tls) {\n            this._connectionParams.protocols[this._protocol] = { tlsPort: this._port };\n          } else {\n            this._connectionParams.protocols[this._protocol] = { port: this._port };\n          }\n          this._endpointConfigs = {\n            connection: this._connectionParams,\n            channels: []\n          };\n          resolve(this._endpointConfigs);\n        }\n      } else if (this._client && this._secret) { // Access key credentials\n        if (this._host && this._port && this._vhost) {\n          // Manually provided configs\n          this._connectionParams.protocols = {};\n          if (this._tls) {\n            this._connectionParams.protocols[this._protocol] = { tlsPort: this._port };\n          } else {\n            this._connectionParams.protocols[this._protocol] = { port: this._port };\n          }\n          this._endpointConfigs = {\n            connection: this._connectionParams,\n            liveStreams: []\n          };\n          resolve(this._endpointConfigs);\n        } else {\n          // Get configs from endpoint\n          // uses endpoint passed from user, default endpoint otherwise\n          const hostname = this._generateHostname();\n          const uri = url.resolve(hostname, this._endpoint.liveStreamKeyConfigurationsPath);\n          const options = {\n            url: uri,\n            method: 'get',\n            responseType: 'json',\n            headers: {\n              'Live-Stream-Key-Client': this._client,\n              'Live-Stream-Key-Secret': this._secret,\n              'Content-Type': 'application/json'\n            }\n          };\n          axios(options).then((response) => {\n            this._endpointConfigs = humps.camelizeKeys(response.data);\n            this._connectionParams = this._endpointConfigs.connection;\n            this._liveStreams = this._endpointConfigs.liveStreams || [];\n            resolve(this._endpointConfigs);\n          }).catch((err) => {\n            reject(err);\n          });\n        }\n      } else { // No configs or missing some info\n        reject(new Error('Missing Device Key or wrong connection parameters'));\n      }\n    });\n  }\n\n  /**\n   * @return all channels configured for the current device\n   */\n  channels() {\n    if (this._endpointConfigs.channels) {\n      this._channels = this._endpointConfigs.channels.map((obj) => {\n        return obj.name;\n      });\n      return this._channels || [];\n    } else {\n      return [];\n    }\n  }\n\n  /**\n   * @return the device ID for the current device\n   */\n  deviceId() {\n    this._deviceId = this._deviceId || this._connectionParams.deviceId;\n    return this._deviceId;\n  }\n\n  /**\n   * Return a Stream ID from a stream name given in input\n   *\n   * @param {String} streamName - stream name\n   * @return the stream ID which corresponds to the input stream name\n   */\n  liveStreamByName(streamName) {\n    const liveStreams = filter(this._liveStreams, (stream) => { return stream.name === streamName; });\n    if (liveStreams.length > 0) {\n      return liveStreams[0].id || streamName;\n    } else {\n      return streamName;\n    }\n  }\n\n  /**\n   * Check if a stream exists\n   *\n   * @param {String} streamName - stream name\n   * @return true if stream exists, false otherwise\n   */\n  liveStreamExists(streamName) {\n    const liveStreams = filter(this._liveStreams, (stream) => { return stream.name === streamName; });\n    return (liveStreams.length > 0);\n  }\n\n  /**\n   * Generate a temporary queue name\n   *\n   * @private\n   * @param {String} prefix - client id or stream name\n   * @param {String} suffix - channel name or defaul live stream suffix\n   * @param {Numeric} currentTime - current timestamp\n   * @return a string that represents the topic name for that channel\n   */\n  tempQueue(prefix, suffix, currentTime) {\n    const timestamp = currentTime || new Date().getTime();\n    const deviceId = this._connectionParams.client || this._connectionParams.deviceId;\n    return `${timestamp}-${deviceId}-`\n      + `${this.exchangeName(prefix, suffix)}.`\n      + `${this._tempQueueSuffix}`;\n  }\n\n  /**\n   * Generate the exchange name for a device's channel\n   *\n   * @private\n   * @param {String} prefix - It could be a device id or a stream name\n   * @param {String} suffix - It could be a channel name or a the default stream suffix (live_stream)\n   * @return a string that represents the complete exchange name\n   */\n  exchangeName(prefix, suffix) {\n    return (prefix && suffix) ? `${this.liveStreamByName(prefix)}.${suffix}` : `${suffix}`;\n  }\n\n  // ------------ PRIVATE METHODS -------------------\n\n  /**\n   * Encapsulates contens for publishing messages.\n   * If the content is a valid JSON the function stringifies the content\n   *\n   * @private\n   * @param {Object} content - content to publish, could be a string or a JSON object\n   * @return the content encapsulated in the proper way\n   */\n  _encapsulateContent(content) {\n    let encapsulatedContent = content;\n    try {\n      encapsulatedContent = JSON.stringify(content);\n    } catch (ex) {\n      encapsulatedContent = content;\n    }\n    return encapsulatedContent;\n  }\n\n  /**\n   * Generate the complete hostname string for an endpoint\n   *\n   * @private\n   * @return the string representing the endpoint url\n   */\n  _generateHostname() {\n    if (this._endpoint.url) {\n      return this._endpoint.url;\n    }\n    let hostname = `${this._endpoint.host}:${this._endpoint.port}`;\n    const protocol = (this._tls) ? this._endpoint.secureProtocol : this._endpoint.protocol;\n    if (!startsWith(hostname, protocol)) {\n      hostname = `${protocol}://${hostname}`;\n    }\n    return hostname;\n  }\n\n  /**\n   * Automatically parse message content\n   *\n   * @private\n   * @param {Object/String} message - the received message\n   * @return an object containing the input message with parsed content\n   */\n  _parseContent(message) {\n    let parsedMessage = message;\n    if (Buffer.isBuffer(parsedMessage)) {\n      parsedMessage = parsedMessage.toString('utf-8');\n    }\n    let res;\n    try {\n      res = JSON.parse(parsedMessage);\n    } catch (ex) {\n      res = parsedMessage;\n    }\n    return res;\n  }\n}\n\nexport default SpaceBunny;\n"],"sourceRoot":"src"}