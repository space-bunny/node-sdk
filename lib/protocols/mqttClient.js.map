{"version":3,"sources":["protocols/mqttClient.js"],"names":[],"mappings":"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","file":"protocols/mqttClient.js","sourcesContent":["/**\n * A module that exports an MqttClient client\n * which inherits from the SpaceBunny base client\n * @module MqttClient\n */\n\n// Import some helpers modules\nimport merge from 'merge';\nimport Promise from 'bluebird';\n\n// Import mqtt library\nimport mqtt from 'mqtt';\n\n// Import SpaceBunny main module from which MqttClient inherits\nimport SpaceBunny from '../spacebunny';\n\nclass MqttClient extends SpaceBunny {\n\n  /**\n   * @constructor\n   * @param {Object} opts - options must contain api-key or connection options\n   * (deviceId and secret) for devices.\n   */\n  constructor(opts) {\n    super(opts);\n    this._protocol = 'mqtt';\n    this._mqttConnection = undefined;\n    this._subscription = undefined;\n    this._connectionOpts = { qos: 1 };\n    this._connectTimeout = 5000;\n    this._topics = {};\n    this.getConnectionParams();\n    this._sslOpts.protocol = 'mqtts';\n    this._sslOpts.rejectUnauthorized = true;\n  }\n\n  /**\n   * Subscribe to input channel\n   *\n   * @param {function} callback - function called every time a message is received\n   * passing the current message as argument\n   * @param {Object} options - subscription options\n   * @return promise containing the result of the subscription\n   */\n  onReceive(callback, opts) {\n    opts = merge({}, opts);\n    // subscribe for input messages\n    return new Promise((resolve, reject) => {\n      this._connect().then((client) => {\n        this._topics[this._topicFor(this._inputTopic)] = opts.qos || this._connectionOpts.qos;\n        client.subscribe(this._topics, merge(this._connectionOpts, opts), (err) => {\n          if (err) {\n            reject(false);\n          } else {\n            client.on('message', (topic, message) => {\n              // TODO filterMine and filterWeb\n              callback(topic, message);\n            });\n            resolve(true);\n          }\n        });\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Publish a message on a specific channel\n   *\n   * @param {String} channel - channel name on which you want to publish a message\n   * @param {Object/String} message - the message payload\n   * @param {Object} opts - publication options\n   * @return a promise containing the result of the operation\n   */\n  publish(channel, message, opts) {\n    // Publish message\n    return new Promise((resolve, reject) => {\n      this._connect().then((client) => {\n        client.on('connect', () => {\n          const bufferedMessage = new Buffer(this._encapsulateContent(message));\n          client.publish(this._topicFor(channel), bufferedMessage, merge(this._connectionOpts, opts), () => {\n            resolve(true);\n          });\n        });\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Unsubscribe client from a list of topics\n   *\n   * @param {Object} topics - list of topics { topic: qos, ... }\n   * e.g. { topic_1: 1, topic_2: 0 }\n   * @return a promise containing the result of the operation\n   */\n  unsubscribe(topics) {\n    return new Promise((resolve, reject) => {\n      this._mqttConnection.unsubscribe(Object.keys(topics)).then(() => {\n        resolve(true);\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Destroy the connection between the mqtt client and broker\n   *\n   * @return a promise containing the result of the operation\n   */\n  disconnect() {\n    return new Promise((resolve, reject) => {\n      if (this._mqttConnection === undefined) {\n        reject('Invalid connection');\n      } else {\n        this._mqttConnection.unsubscribe(this._topics).then(() => {\n          this._mqttConnection.end().then(() => {\n            this._mqttConnection = undefined;\n            resolve(true);\n          });\n        }).catch((reason) => {\n          reject(reason);\n        });\n      }\n    });\n  }\n\n  // ------------ PRIVATE METHODS -------------------\n\n  /**\n   * Establish an mqtt connection with the broker.\n   * If a connection already exists, returns the current connection\n   *\n   * @private\n   * @param {Object} opts - connection options\n   * @return a promise containing current connection\n   */\n  _connect(opts) {\n    opts = merge({}, opts);\n    const connectionParams = this._connectionParams;\n\n    return new Promise((resolve, reject) => {\n      if (this._mqttConnection !== undefined) {\n        resolve(this._mqttConnection);\n      } else {\n        try {\n          let mqttConnectionParams = {\n            host: connectionParams.host,\n            port: (this._ssl) ? connectionParams.protocols.mqtt.sslPort : connectionParams.protocols.mqtt.port,\n            username: `${connectionParams.vhost}:${connectionParams.deviceId || connectionParams.client}`,\n            password: connectionParams.secret,\n            clientId: connectionParams.deviceId || connectionParams.client,\n            connectTimeout: opts.connectTimeout || this._connectTimeout\n          };\n          if (this._ssl) {\n            mqttConnectionParams = merge(mqttConnectionParams, this._sslOpts);\n          }\n          const client = mqtt.connect(mqttConnectionParams);\n          client.on('error', (reason) => {\n            reject(reason);\n          });\n          client.on('close', (reason) => {\n            reject(reason);\n          });\n          this._mqttConnection = client;\n          resolve(this._mqttConnection);\n        } catch (reason) {\n          reject(reason);\n        }\n      }\n    });\n  }\n\n  /**\n   * Generate the topic for a specific channel\n   *\n   * @private\n   * @param {String} channel - channel name on which you want to publish a message\n   * @return a string that represents the topic name for that channel\n   */\n  _topicFor(channel) {\n    return `${this.deviceId()}/${channel}`;\n  }\n}\n\nexport default MqttClient;\n"],"sourceRoot":"/Users/gfoiani/Dev/work/spacebunny/sdk/node/src"}