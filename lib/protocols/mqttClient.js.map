{"version":3,"sources":["protocols/mqttClient.js"],"names":[],"mappings":"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","file":"protocols/mqttClient.js","sourcesContent":["/**\n * A module that exports an MqttClient client\n * which inherits from the SpaceBunny base client\n * @module MqttClient\n */\n\n// Import some helpers modules\nimport merge from 'merge';\nimport Promise from 'bluebird';\nimport _ from 'lodash';\n\n// Import mqtt library\nimport mqtt from 'mqtt';\n\n// Import SpaceBunny main module from which MqttClient inherits\nimport SpaceBunny from '../spacebunny';\n\nconst CONFIG = require('../../config/constants').CONFIG;\n\nclass MqttClient extends SpaceBunny {\n\n  /**\n   * @constructor\n   * @param {Object} opts - options must contain Device-Key or connection options\n   * (deviceId and secret) for devices.\n   */\n  constructor(opts) {\n    super(opts);\n    this._topics = {};\n    this._mqttConnection = undefined;\n    this._subscription = undefined;\n    const mqttOptions = CONFIG.mqtt;\n    this._protocol = mqttOptions.protocol;\n    this._sslOpts.protocol = mqttOptions.ssl.protocol;\n    this._sslOpts.rejectUnauthorized = mqttOptions.ssl.rejectUnauthorized;\n    this._connectionOpts = mqttOptions.connection.opts;\n    this._connectionTimeout = mqttOptions.connection.timeout;\n  }\n\n  /**\n   * Subscribe to input channel\n   *\n   * @param {function} callback - function called every time a message is received\n   * passing the current message as argument\n   * @param {Object} options - subscription options\n   * @return promise containing the result of the subscription\n   */\n  onReceive(callback, opts) {\n    opts = merge({}, opts);\n    // subscribe for input messages\n    return new Promise((resolve, reject) => {\n      this._connect().then((client) => {\n        this._topics[this._topicFor(this._inboxTopic)] = opts.qos || this._connectionOpts.qos;\n        client.subscribe(this._topics, merge(this._connectionOpts, opts), (err) => {\n          if (err) {\n            reject(false);\n          } else {\n            client.on('message', (topic, message) => {\n              // TODO filterMine and filterWeb\n              callback(topic, this._parseContent(message));\n            });\n            resolve(true);\n          }\n        });\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Publish a message on a specific channel\n   *\n   * @param {String} channel - channel name on which you want to publish a message\n   * @param {Object/String} message - the message payload\n   * @param {Object} opts - publication options\n   * @return a promise containing the result of the operation\n   */\n  publish(channel, message, opts) {\n    // Publish message\n    return new Promise((resolve, reject) => {\n      this._connect().then((client) => {\n        const _sendMessage = () => {\n          const bufferedMessage = new Buffer(this._encapsulateContent(message));\n          client.publish(this._topicFor(channel), bufferedMessage, merge(this._connectionOpts, opts), () => {\n            resolve(true);\n          });\n        };\n        if (!client.connected) {\n          client.on('connect', () => { _sendMessage(); });\n        } else {\n          _sendMessage();\n        }\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Unsubscribe client from a list of topics\n   *\n   * @param {Object} topics - list of topics { topic: qos, ... }\n   * e.g. { topic_1: 1, topic_2: 0 }\n   * @return a promise containing the result of the operation\n   */\n  unsubscribe(topics) {\n    return new Promise((resolve, reject) => {\n      try {\n        if (_.isEmpty(topics)) {\n          resolve(true);\n        } else {\n          this._mqttConnection.unsubscribe(Object.keys(topics), () => {\n            resolve(true);\n          });\n        }\n      } catch (reason) {\n        reject(reason);\n      }\n    });\n  }\n\n  /**\n   * Destroy the connection between the mqtt client and broker\n   *\n   * @return a promise containing the result of the operation\n   */\n  disconnect() {\n    return new Promise((resolve, reject) => {\n      if (this._mqttConnection === undefined) {\n        reject('Invalid connection');\n      } else {\n        const _closeConnection = () => {\n          this._mqttConnection.end(true, () => {\n            this._mqttConnection = undefined;\n            resolve(true);\n          });\n        };\n        try {\n          if (_.isEmpty(this._topics)) {\n            _closeConnection();\n          } else {\n            this._mqttConnection.unsubscribe(Object.keys(this._topics), () => {\n              _closeConnection();\n            });\n          }\n        } catch (reason) {\n          reject(reason);\n        }\n      }\n    });\n  }\n\n  // ------------ PRIVATE METHODS -------------------\n\n  /**\n   * Establish an mqtt connection with the broker.\n   * If a connection already exists, returns the current connection\n   *\n   * @private\n   * @param {Object} opts - connection options\n   * @return a promise containing current connection\n   */\n  _connect(opts) {\n    opts = merge({}, opts);\n\n    return new Promise((resolve, reject) => {\n      this.getEndpointConfigs().then((endpointConfigs) => {\n        const connectionParams = endpointConfigs.connection;\n        if (this._mqttConnection !== undefined) {\n          resolve(this._mqttConnection);\n        } else {\n          try {\n            let mqttConnectionParams = {\n              host: connectionParams.host,\n              port: (this._ssl) ? connectionParams.protocols.mqtt.sslPort : connectionParams.protocols.mqtt.port,\n              username: `${connectionParams.vhost}:${connectionParams.deviceId || connectionParams.client}`,\n              password: connectionParams.secret,\n              clientId: connectionParams.deviceId || connectionParams.client,\n              connectionTimeout: opts.connectionTimeout || this._connectionTimeout\n            };\n            if (this._ssl) {\n              mqttConnectionParams = merge(mqttConnectionParams, this._sslOpts);\n            }\n            const client = mqtt.connect(mqttConnectionParams);\n            client.on('error', (reason) => {\n              reject(reason);\n            });\n            client.on('close', (reason) => {\n              reject(reason);\n            });\n            this._mqttConnection = client;\n            resolve(this._mqttConnection);\n          } catch (reason) {\n            reject(reason);\n          }\n        }\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Generate the topic for a specific channel\n   *\n   * @private\n   * @param {String} channel - channel name on which you want to publish a message\n   * @return a string that represents the topic name for that channel\n   */\n  _topicFor(channel) {\n    return `${this.deviceId()}/${channel}`;\n  }\n}\n\nexport default MqttClient;\n"],"sourceRoot":"/Users/gfoiani/Dev/work/spacebunny/sdk/node/src"}