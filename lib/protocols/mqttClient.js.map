{"version":3,"sources":["protocols/mqttClient.js"],"names":[],"mappings":"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","file":"protocols/mqttClient.js","sourcesContent":["/**\n * A module that exports an MqttClient client\n * which inherits from the SpaceBunny base client\n * @module MqttClient\n */\n\n// Import some helpers modules\nimport merge from 'merge';\nimport Promise from 'bluebird';\n\n// Import mqtt library\nimport mqtt from 'mqtt';\n\n// Import SpaceBunny main module from which MqttClient inherits\nimport SpaceBunny from '../spacebunny';\n\nclass MqttClient extends SpaceBunny {\n\n  /**\n   * @constructor\n   * @param {Object} opts - options must contain api-key or connection options\n   * (deviceId and secret) for devices.\n   */\n  constructor(opts) {\n    super(opts);\n    this._protocol = 'mqtt';\n    this._mqttConnection = undefined;\n    this._subscription = undefined;\n    this._connectionOpts = { qos: 1 };\n    this._connectTimeout = 5000;\n    this._topics = {};\n    this.getConnectionParams();\n    this._sslOpts.protocol = 'mqtts';\n    this._sslOpts.rejectUnauthorized = true;\n  }\n\n  /**\n   * Subscribe to input channel\n   *\n   * @param {function} callback - function called every time a message is received\n   * passing the current message as argument\n   * @param {Object} options - subscription options\n   * @return promise containing the result of the subscription\n   */\n  onReceive(callback, opts) {\n    opts = merge({}, opts);\n    // subscribe for input messages\n    return new Promise((resolve, reject) => {\n      this._connect().then((client) => {\n        this._topics[this._topicFor(this._inputTopic)] = opts.qos || this._connectionOpts.qos;\n        client.subscribe(this._topics, merge(this._connectionOpts, opts), function(err) {\n          if (err) {\n            reject(false);\n          } else {\n            client.on('message', function(topic, message) {\n              callback(topic, message);\n            });\n            resolve(true);\n          }\n        });\n      }).catch(function(reason) {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Publish a message on a specific channel\n   *\n   * @param {String} channel - channel name on which you want to publish a message\n   * @param {Object/String} message - the message payload\n   * @param {Object} opts - publication options\n   * @return a promise containing the result of the operation\n   */\n  publish(channel, message, opts) {\n    // Publish message\n    return new Promise((resolve, reject) => {\n      this._connect().then((client) => {\n        client.on('connect', () => {\n          const bufferedMessage = new Buffer(this._encapsulateContent(message));\n          client.publish(this._topicFor(channel), bufferedMessage, merge(this._connectionOpts, opts), function() {\n            resolve(true);\n          });\n        });\n      }).catch(function(reason) {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Unsubscribe client from a list of topics\n   *\n   * @param {Object} topics - list of topics { topic: qos, ... }\n   * e.g. { topic_1: 1, topic_2: 0 }\n   * @return a promise containing the result of the operation\n   */\n  unsubscribe(topics) {\n    return new Promise((resolve, reject) => {\n      this._mqttConnection.unsubscribe(Object.keys(topics)).then(function() {\n        resolve(true);\n      }).catch(function(reason) {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Destroy the connection between the mqtt client and broker\n   *\n   * @return a promise containing the result of the operation\n   */\n  disconnect() {\n    return new Promise((resolve, reject) => {\n      if (this._mqttConnection === undefined) {\n        reject('Invalid connection');\n      } else {\n        this._mqttConnection.unsubscribe(this._topics).then(() => {\n          this._mqttConnection.end().then(() => {\n            this._mqttConnection = undefined;\n            resolve(true);\n          });\n        }).catch(function(reason) {\n          reject(reason);\n        });\n      }\n    });\n  }\n\n  // ------------ PRIVATE METHODS -------------------\n\n  /**\n   * Establish an mqtt connection with the broker.\n   * If a connection already exists, returns the current connection\n   *\n   * @private\n   * @param {Object} opts - connection options\n   * @return a promise containing current connection\n   */\n  _connect(opts) {\n    opts = merge({}, opts);\n    const connectionParams = this._connectionParams;\n\n    return new Promise((resolve, reject) => {\n      if (this._mqttConnection !== undefined) {\n        resolve(this._mqttConnection);\n      } else {\n        try {\n          let mqttConnectionParams = {\n            host: connectionParams.host,\n            port: (this._ssl) ? connectionParams.protocols.mqtt.sslPort : connectionParams.protocols.mqtt.port,\n            username: `${connectionParams.vhost}:${connectionParams.deviceId || connectionParams.client}`,\n            password: connectionParams.secret,\n            clientId: connectionParams.deviceId || connectionParams.client,\n            connectTimeout: opts.connectTimeout || this._connectTimeout\n          };\n          if (this._ssl) {\n            mqttConnectionParams = merge(mqttConnectionParams, this._sslOpts);\n          }\n          const client = mqtt.connect(mqttConnectionParams);\n          client.on('error', function(reason) {\n            reject(reason);\n          });\n          client.on('close', function(reason) {\n            reject(reason);\n          });\n          this._mqttConnection = client;\n          resolve(this._mqttConnection);\n        } catch (reason) {\n          reject(reason);\n        }\n      }\n    });\n  }\n\n  /**\n   * Generate the topic for a specific channel\n   *\n   * @private\n   * @param {String} channel - channel name on which you want to publish a message\n   * @return a string that represents the topic name for that channel\n   */\n  _topicFor(channel) {\n    return this.deviceId().concat('/', channel);\n  }\n}\n\nexport default MqttClient;\n"],"sourceRoot":"/Users/gfoiani/Dev/work/spacebunny/sdk-node/src"}