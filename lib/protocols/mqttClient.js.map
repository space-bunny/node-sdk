{"version":3,"sources":["protocols/mqttClient.js"],"names":["require","CONFIG","MqttClient","opts","_topics","_mqttConnection","undefined","_subscription","mqttOptions","mqtt","_protocol","protocol","_tlsOpts","tls","rejectUnauthorized","_connectionOpts","connection","_connectionTimeout","timeout","callback","Promise","resolve","reject","localOpts","connect","then","client","_topicFor","_inboxTopic","qos","subscribe","err","on","topic","message","catch","reason","channel","_sendMessage","bufferedMessage","Buffer","from","publish","connected","topics","unsubscribe","Object","keys","Error","_closeConnection","end","emit","getEndpointConfigs","endpointConfigs","connectionParams","mqttConnectionParams","host","port","_tls","protocols","tlsPort","username","vhost","deviceId","password","secret","clientId","connectionTimeout","SpaceBunny"],"mappings":"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","file":"mqttClient.js","sourcesContent":["/**\n * A module that exports an MqttClient client\n * which inherits from the SpaceBunny base client\n * @module MqttClient\n */\n\n// Import some helpers modules\nimport Promise from 'bluebird';\nimport _ from 'lodash';\n\n// Import mqtt library\nimport mqtt from 'mqtt';\n\n// Import SpaceBunny main module from which MqttClient inherits\nimport SpaceBunny from '../spacebunny';\nimport { parseContent, encapsulateContent } from '../utils';\n\nconst { CONFIG } = require('../../config/constants');\n\nclass MqttClient extends SpaceBunny {\n  /**\n   * @constructor\n   * @param {Object} opts - options must contain Device-Key or connection options\n   * (deviceId and secret) for devices.\n   */\n  constructor(opts = {}) {\n    super(opts);\n    this._topics = {};\n    this._mqttConnection = undefined;\n    this._subscription = undefined;\n    const mqttOptions = CONFIG.mqtt;\n    this._protocol = mqttOptions.protocol;\n    this._tlsOpts.protocol = mqttOptions.tls.protocol;\n    this._tlsOpts.rejectUnauthorized = mqttOptions.tls.rejectUnauthorized;\n    this._connectionOpts = mqttOptions.connection.opts;\n    this._connectionTimeout = mqttOptions.connection.timeout;\n  }\n\n  /**\n   * Subscribe to input channel\n   *\n   * @param {function} callback - function called every time a message is received\n   * passing the current message as argument\n   * @param {Object} options - subscription options\n   * @return promise containing the result of the subscription\n   */\n  onReceive(callback, opts = {}) {\n    // subscribe for input messages\n    return new Promise((resolve, reject) => {\n      let localOpts = _.cloneDeep(opts);\n      localOpts = _.merge({}, localOpts);\n      this.connect().then((client) => {\n        this._topics[this._topicFor(null, this._inboxTopic)] = localOpts.qos || this._connectionOpts.qos;\n        client.subscribe(this._topics, _.merge(_.cloneDeep(this._connectionOpts), localOpts), (err) => {\n          if (err) {\n            reject(err);\n          } else {\n            client.on('message', (topic, message) => {\n              // TODO filterMine and filterWeb\n              callback(topic, parseContent(message));\n            });\n            resolve(true);\n          }\n        });\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Publish a message on a specific channel\n   *\n   * @param {String} channel - channel name on which you want to publish a message\n   * @param {Object/String} message - the message payload\n   * @param {Object} opts - publication options\n   * @return a promise containing the result of the operation\n   */\n  publish(channel, message, opts = {}) {\n    // Publish message\n    return new Promise((resolve, reject) => {\n      this.connect().then((client) => {\n        const _sendMessage = () => {\n          const bufferedMessage = Buffer.from(encapsulateContent(message));\n          let localOpts = _.cloneDeep(opts);\n          localOpts = _.merge(_.cloneDeep(this._connectionOpts), localOpts);\n          client.publish(this._topicFor(null, channel), bufferedMessage, localOpts, () => {\n            resolve(true);\n          });\n        };\n        if (!client.connected) {\n          client.on('connect', () => { _sendMessage(); });\n        } else {\n          _sendMessage();\n        }\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Unsubscribe client from a list of topics\n   *\n   * @param {Object} topics - list of topics { topic: qos, ... }\n   * e.g. { topic_1: 1, topic_2: 0 }\n   * @return a promise containing the result of the operation\n   */\n  unsubscribe(topics) {\n    return new Promise((resolve, reject) => {\n      try {\n        if (_.isEmpty(topics)) {\n          resolve(true);\n        } else {\n          this._mqttConnection.unsubscribe(Object.keys(topics), () => {\n            resolve(true);\n          });\n        }\n      } catch (reason) {\n        reject(reason);\n      }\n    });\n  }\n\n  /**\n   * Destroy the connection between the mqtt client and broker\n   *\n   * @return a promise containing the result of the operation\n   */\n  disconnect() {\n    return new Promise((resolve, reject) => {\n      if (this._mqttConnection === undefined) {\n        reject(new Error('Invalid connection'));\n      } else {\n        const _closeConnection = () => {\n          this._mqttConnection.end(true, () => {\n            this._mqttConnection = undefined;\n            this.emit('disconnect');\n            resolve(true);\n          });\n        };\n        try {\n          if (_.isEmpty(this._topics)) {\n            _closeConnection();\n          } else {\n            this._mqttConnection.unsubscribe(Object.keys(this._topics), () => {\n              _closeConnection();\n            });\n          }\n        } catch (reason) {\n          reject(reason);\n        }\n      }\n    });\n  }\n\n  /**\n   * Establish an mqtt connection with the broker.\n   * If a connection already exists, returns the current connection\n   *\n   * @param {Object} opts - connection options\n   * @return a promise containing current connection\n   */\n  connect(opts = {}) {\n    return new Promise((resolve, reject) => {\n      let localOpts = _.cloneDeep(opts);\n      localOpts = _.merge(_.cloneDeep(this._connectionOpts), localOpts);\n      this.getEndpointConfigs().then((endpointConfigs) => {\n        const connectionParams = endpointConfigs.connection;\n        if (this._mqttConnection !== undefined) {\n          resolve(this._mqttConnection);\n        } else {\n          try {\n            let mqttConnectionParams = {\n              host: connectionParams.host,\n              port: (this._tls) ? connectionParams.protocols.mqtt.tlsPort : connectionParams.protocols.mqtt.port,\n              username: `${connectionParams.vhost}:${connectionParams.deviceId || connectionParams.client}`,\n              password: connectionParams.secret,\n              clientId: connectionParams.deviceId || connectionParams.client,\n              connectionTimeout: localOpts.connectionTimeout || this._connectionTimeout\n            };\n            if (this._tls) {\n              mqttConnectionParams = _.merge(mqttConnectionParams, this._tlsOpts);\n            }\n            const client = mqtt.connect(mqttConnectionParams);\n            client.on('error', (reason) => {\n              this.emit('error', reason);\n              reject(reason);\n            });\n            client.on('close', (reason) => {\n              reject(reason);\n              this.emit('close', reason);\n              this._mqttConnection = undefined;\n            });\n            this._mqttConnection = client;\n            this.emit('connect');\n            resolve(this._mqttConnection);\n          } catch (reason) {\n            reject(reason);\n          }\n        }\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  isConnected() {\n    return (this._mqttConnection !== undefined);\n  }\n\n  // ------------ PRIVATE METHODS -------------------\n\n  /**\n   * Generate the topic for a specific channel\n   *\n   * @private\n   * @param {String} deviceId - device id\n   * @param {String} channel - channel name on which you want to publish a message\n   * @return a string that represents the topic name for that channel\n   */\n  _topicFor(deviceId, channel) {\n    return `${deviceId || this.deviceId()}/${channel}`;\n  }\n}\n\nexport default MqttClient;\n"],"sourceRoot":"../src"}