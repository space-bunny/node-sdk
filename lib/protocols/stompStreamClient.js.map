{"version":3,"sources":["protocols/stompStreamClient.js"],"names":["CONFIG","require","StompStreamClient","opts","_subscriptions","stompStreamOpts","stomp","stream","_exchangePrefix","exchangePrefix","_defaultPattern","defaultPattern","streamHooks","successCallback","errorCallback","promises","map","streamHook","_attachStreamHook","length","Promise","any","reject","Error","deviceId","channel","resolve","_stompConnection","undefined","topic","_streamChannelTopicFor","subscription","unsubscribe","_streamTopicFor","disconnect","catch","reason","cache","emptyFunction","callback","connect","then","client","tempQueue","liveStreamExists","console","error","_cachedStreamTopicFor","_liveStreamSuffix","subscriptionHeaders","messageCallback","message","_parseContent","body","headers","subscribe","type","pattern","streamName","_existingQueuePrefix","liveStreamByName","StompClient","onReceive","publish","_subcriptionFor","_destinationFor"],"mappings":"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","file":"stompStreamClient.js","sourcesContent":["/**\n * A module that exports an StompStreamClient client\n * which inherits from the Stomp base client\n * @module StompStreamClient\n */\n\n// Import some helpers modules\nimport merge from 'merge';\nimport Promise from 'bluebird';\n\n// Import StompClient main module from which StompStreamClient inherits\nimport StompClient from './stompClient';\n\nconst CONFIG = require('../../config/constants').CONFIG;\n\nclass StompStreamClient extends StompClient {\n  /**\n   * @constructor\n   * @param {Object} opts - options must contain client and secret for access keys\n   */\n  constructor(opts) {\n    super(opts);\n    this._subscriptions = {};\n    const stompStreamOpts = CONFIG.stomp.stream;\n    this._exchangePrefix = stompStreamOpts.exchangePrefix;\n    this._defaultPattern = stompStreamOpts.defaultPattern;\n  }\n\n  /**\n   * Subscribe to multiple stream hooks\n   *\n   * @param {Array} streamHooks - Array of objects. Each objects containing\n   * { deviceId: {string}, channel: {string}, callback: {func} }\n   * @param {Object} options - subscription options\n   * @return promise containing the result of multiple subscriptions\n   */\n  streamFrom(streamHooks = [], opts, successCallback, errorCallback) {\n    const promises = streamHooks.map((streamHook) => {\n      return this._attachStreamHook(streamHook, opts);\n    }) || [];\n    if (promises.length > 0) {\n      return Promise.any(promises);\n    } else {\n      return Promise.reject(new Error('Missing stream hooks'));\n    }\n  }\n\n  /**\n   * Unsubscribe client from a topic\n   *\n   * @param {String} deviceId - Device uuid\n   * @param {String} channel - channel name\n   * @return a promise containing the result of the operation\n   */\n  unsubscribe(deviceId, channel) {\n    return new Promise((resolve, reject) => {\n      if (this._stompConnection === undefined) {\n        reject(new Error('Invalid connection'));\n      } else {\n        const topic = this._streamChannelTopicFor(deviceId, channel);\n        const subscription = this._subscriptions[topic];\n        subscription.unsubscribe(topic);\n        delete this._subscriptions[topic];\n        resolve(true);\n      }\n    });\n  }\n\n  /**\n   * Unsubscribe client from a topic\n   *\n   * @param {String} stream - Device uuid\n   * @return a promise containing the result of the operation\n   */\n  unsubscribeStream(stream) {\n    return new Promise((resolve, reject) => {\n      if (this._stompConnection === undefined) {\n        reject(new Error('Invalid connection'));\n      } else {\n        const topic = this._streamTopicFor(stream);\n        const subscription = this._subscriptions[topic];\n        subscription.unsubscribe(topic);\n        delete this._subscriptions[topic];\n        resolve(true);\n      }\n    });\n  }\n\n  /**\n   * Destroy the connection between the stomp client and broker\n   *\n   * @return a promise containing the result of the operation\n   */\n  disconnect() {\n    return new Promise((resolve, reject) => {\n      if (this._stompConnection === undefined) {\n        reject(new Error('Invalid connection'));\n      } else {\n        for (const subscription in this._subscriptions) {\n          if (subscription) {\n            this._subscriptions[subscription].unsubscribe();\n          }\n        }\n        this._subscriptions = {};\n        this._stompConnection.disconnect(() => {\n          this._stompConnection = undefined;\n          resolve(true);\n        }).catch((reason) => {\n          reject(reason);\n        });\n      }\n    });\n  }\n\n  // ------------ PRIVATE METHODS -------------------\n\n  /**\n   * Start consuming messages from a device's channel\n   * It generates an auto delete queue from which consume\n   * and binds it to the channel exchange\n   *\n   * @private\n   * @param {Object} streamHook - Object containit hook info\n   * { deviceId: {String}, channel: {String}, callback: {func}}\n   * @param {Object} opts - connection options\n   * @return a promise containing current connection\n   */\n  _attachStreamHook(streamHook, opts) {\n    opts = merge({}, opts);\n    return new Promise((resolve, reject) => {\n      // Receive messages from imput queue\n      const stream = streamHook.stream;\n      const deviceId = streamHook.deviceId;\n      const channel = streamHook.channel;\n      const cache = (typeof (streamHook.cache) !== 'boolean') ? true : streamHook.cache;\n      const emptyFunction = () => { return undefined; };\n      const callback = streamHook.callback || emptyFunction;\n      if (stream === undefined && (channel === undefined || deviceId === undefined)) {\n        reject(new Error('Missing Stream or Device ID and Channel'));\n      }\n      this.connect().then((client) => {\n        let topic;\n        let tempQueue;\n        if (stream) {\n          if (!this.liveStreamExists(stream)) {\n            console.error(`Stream ${stream} does not exist`); // eslint-disable-line no-console\n            resolve(false);\n          }\n          if (cache) {\n            // Cached streams are connected to the existing live stream queue\n            topic = this._cachedStreamTopicFor(stream);\n          } else {\n            // Uncached streams are connected to the stream exchange and create a temp queue\n            topic = this._streamTopicFor(stream);\n            tempQueue = this.tempQueue(stream, this._liveStreamSuffix);\n          }\n        } else {\n          // else if current hook is channel (or a couple deviceId, channel)\n          // creates a temp queue, binds to channel exchange and starts consuming\n          topic = this._streamChannelTopicFor(deviceId, channel);\n          tempQueue = this.tempQueue(deviceId, channel);\n        }\n        const subscriptionHeaders = {};\n        if (tempQueue) { subscriptionHeaders['x-queue-name'] = tempQueue; }\n        const messageCallback = (message) => {\n          callback(this._parseContent(message.body), message.headers);\n        };\n        const subscription = client.subscribe(topic, messageCallback, subscriptionHeaders);\n        this._subscriptions[topic] = subscription;\n        resolve(true);\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Generate the subscription string for a specific channel\n   *\n   * @private\n   * @param {String} deviceId - deviceId from which you want to stream from\n   * @param {String} channel - channel name from which you want to stream from\n   * @param {String} type - resource type on which subscribe or publish [exchange/queue]\n   * @param {String} pattern - binding pattern\n   * @return a string that represents the topic name for that channel\n   */\n  _streamChannelTopicFor(deviceId, channel, type, pattern) {\n    return `/${type || this._exchangePrefix}/${deviceId}.${channel}/${pattern || this._defaultPattern}`;\n  }\n\n  /**\n   * Generate the subscription string for cached live streams\n   *\n   * @private\n   * @param {String} streamName - stream name from which you want to stream\n   * @param {String} type - resource type on which subscribe or publish [exchange/queue]\n   * @return a string that represents the topic name for that channel\n   */\n  _cachedStreamTopicFor(streamName, type) {\n    return `/${type || this._existingQueuePrefix}/${this.liveStreamByName(streamName)}.`\n      + `${this._liveStreamSuffix}`;\n  }\n\n  /**\n   * Generate the subscription for live streams without caching\n   *\n   * @private\n   * @param {String} streamName - stream name from which you want to stream\n   * @param {String} type - resource type on which subscribe or publish [exchange/queue]\n   * @param {String} pattern - binding pattern\n   * @return a string that represents the topic name for that channel\n   */\n  _streamTopicFor(streamName, type, pattern) {\n    return `/${type || this._exchangePrefix}/${this.liveStreamByName(streamName)}.`\n      + `${this._liveStreamSuffix}/${pattern || this._defaultPattern}`;\n  }\n}\n\n// Remove unwnated methods inherited from StompClient\ndelete StompStreamClient.onReceive;\ndelete StompStreamClient.publish;\ndelete StompStreamClient._subcriptionFor;\ndelete StompStreamClient._destinationFor;\n\nexport default StompStreamClient;\n"],"sourceRoot":"../src"}