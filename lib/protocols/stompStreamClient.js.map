{"version":3,"sources":["protocols/stompStreamClient.js"],"names":["require","CONFIG","StompStreamClient","opts","_subscriptions","stompStreamOpts","stomp","stream","_defaultResource","defaultResource","_defaultPattern","defaultPattern","streamHooks","length","Promise","mapSeries","streamHook","_attachStreamHook","reject","Error","subscriptionId","undefined","resolve","isConnected","subscription","unsubscribe","subscriptions","Object","keys","forEach","_stompConnection","disconnect","catch","reason","deviceId","channel","routingKey","topic","cache","emptyFunction","callback","connect","then","client","streamTopic","tempQueue","liveStreamExists","console","error","_cachedStreamTopicFor","_streamTopicFor","_liveStreamSuffix","_streamChannelTopicFor","subscriptionHeaders","messageCallback","message","body","headers","subscribe","id","e","params","type","resource","finalTopic","_existingQueuePrefix","StompClient","onReceive","publish","_subcriptionFor","_destinationFor"],"mappings":"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","file":"stompStreamClient.js","sourcesContent":["/**\n * A module that exports an StompStreamClient client\n * which inherits from the Stomp base client\n * @module StompStreamClient\n */\n\n// Import some helpers modules\nimport _ from 'lodash';\nimport Promise from 'bluebird';\nimport md5 from 'js-md5';\n\n// Import StompClient main module from which StompStreamClient inherits\nimport StompClient from './stompClient';\nimport { parseContent } from '../utils';\n\nconst { CONFIG } = require('../../config/constants');\n\nclass StompStreamClient extends StompClient {\n  /**\n   * @constructor\n   * @param {Object} opts - options must contain client and secret for access keys\n   */\n  constructor(opts = {}) {\n    super(opts);\n    this._subscriptions = {};\n    const stompStreamOpts = CONFIG.stomp.stream;\n    this._defaultResource = CONFIG.stomp.defaultResource;\n    this._defaultPattern = stompStreamOpts.defaultPattern;\n  }\n\n  /**\n   * Subscribe to multiple stream hooks\n   *\n   * @param {Array} streamHooks - Array of objects. Each objects containing\n   * { deviceId: {string}, channel: {string}, callback: {func} }\n   * @param {Object} options - subscription options\n   * @return promise containing the result of multiple subscriptions\n   */\n  streamFrom(streamHooks = [], opts = {}) {\n    if (streamHooks.length > 0) {\n      return Promise.mapSeries(streamHooks, (streamHook) => {\n        return this._attachStreamHook(streamHook, opts);\n      });\n    } else {\n      return Promise.reject(new Error('Missing stream hooks'));\n    }\n  }\n\n  /**\n   * Unsubscribe client from a topic\n   *\n   * @param {String} subscriptionId - subscription ID\n   * @return a promise containing the result of the operation\n   */\n  unsubscribe(subscriptionId = undefined) {\n    return new Promise((resolve, reject) => {\n      if (!this.isConnected()) {\n        reject(new Error('Invalid connection'));\n      } else {\n        const subscription = this._subscriptions[subscriptionId];\n        if (subscription) {\n          subscription.unsubscribe();\n          delete this._subscriptions[subscriptionId];\n          resolve(true);\n        } else {\n          reject(new Error('Subscription not found'));\n        }\n      }\n    });\n  }\n\n  /**\n   * Destroy the connection between the stomp client and broker\n   *\n   * @return a promise containing the result of the operation\n   */\n  disconnect() {\n    return new Promise((resolve, reject) => {\n      if (!this.isConnected()) {\n        reject(new Error('Invalid connection'));\n      } else {\n        const subscriptions = Object.keys(this._subscriptions);\n        subscriptions.forEach((subscription) => {\n          if (this._subscriptions[subscription]) {\n            this._subscriptions[subscription].unsubscribe();\n          }\n        });\n        this._subscriptions = {};\n        this._stompConnection.disconnect(() => {\n          this._stompConnection = undefined;\n          resolve(true);\n        }).catch((reason) => {\n          reject(reason);\n        });\n      }\n    });\n  }\n\n  // ------------ PRIVATE METHODS -------------------\n\n  /**\n   * Start consuming messages from a device's channel\n   * It generates an auto delete queue from which consume\n   * and binds it to the channel exchange\n   *\n   * @private\n   * @param {Object} streamHook - Object containit hook info\n   * { deviceId: {String}, channel: {String}, callback: {func}}\n   * @param {Object} opts - connection options\n   * @return a promise containing current connection\n   */\n  _attachStreamHook(streamHook, opts = {}) {\n    return new Promise((resolve, reject) => {\n      // let localOpts = _.cloneDeep(opts);\n      // localOpts = _.merge({}, localOpts);\n      // Receive messages from imput queue\n      const {\n        stream = undefined, deviceId = undefined, channel = undefined, routingKey = undefined, topic = undefined\n      } = streamHook;\n      const cache = (typeof (streamHook.cache) !== 'boolean') ? true : streamHook.cache;\n      const emptyFunction = () => { return undefined; };\n      const callback = streamHook.callback || emptyFunction;\n      if (stream === undefined && deviceId === undefined) {\n        reject(new Error('Missing Stream or Device ID'));\n      }\n      this.connect().then((client) => {\n        let streamTopic;\n        let tempQueue;\n        if (stream) {\n          if (!this.liveStreamExists(stream)) {\n            console.error(`Stream ${stream} does not exist`); // eslint-disable-line no-console\n            resolve(false);\n          }\n          if (cache) {\n            // Cached streams are connected to the existing live stream queue\n            streamTopic = this._cachedStreamTopicFor({ stream });\n          } else {\n            // Uncached streams are connected to the stream exchange and create a temp queue\n            streamTopic = this._streamTopicFor({ stream, routingKey, topic });\n            tempQueue = this.tempQueue(stream, this._liveStreamSuffix);\n          }\n        } else {\n          // else if current hook is channel (or a couple deviceId, channel)\n          // creates a temp queue, binds to channel exchange and starts consuming\n          streamTopic = this._streamChannelTopicFor({\n            deviceId, channel, routingKey, topic\n          });\n          tempQueue = this.tempQueue(deviceId, channel);\n        }\n        const subscriptionHeaders = {};\n        if (tempQueue) { subscriptionHeaders['x-queue-name'] = tempQueue; }\n        const messageCallback = (message) => {\n          callback(parseContent(message.body), message.headers);\n        };\n        try {\n          const subscriptionId = md5(`${tempQueue}-${streamTopic}`);\n          const subscription = client.subscribe(streamTopic, messageCallback, {\n            ...subscriptionHeaders,\n            id: subscriptionId\n          });\n          this._subscriptions[subscriptionId] = subscription;\n          resolve(_.merge(streamHook, { id: subscriptionId }));\n        } catch (e) {\n          console.error(e); // eslint-disable-line no-console\n          resolve(undefined);\n        }\n      }).catch((reason) => {\n        console.error(reason); // eslint-disable-line no-console\n        resolve(undefined);\n      });\n    });\n  }\n\n  /**\n   * Generate the subscription string for a specific channel\n   *\n   * @private\n   * @param {String} deviceId - deviceId from which you want to stream from\n   * @param {String} channel - channel name from which you want to stream from\n   * @param {String} type - resource type on which subscribe or publish [exchange/queue]\n   * @param {String} routingKey - binding pattern\n   * @return a string that represents the topic name for that channel\n   */\n  _streamChannelTopicFor(params = {}) {\n    const {\n      deviceId = undefined, channel = undefined, type = this._defaultResource,\n      routingKey = this._defaultPattern, topic = undefined\n    } = params;\n    let resource = deviceId;\n    if (channel) {\n      resource += `.${channel}`;\n    }\n    let finalTopic = resource;\n    if (topic) {\n      finalTopic += `.${topic}`;\n    } else {\n      finalTopic = routingKey;\n    }\n    return `/${type}/${resource}/${finalTopic}`;\n  }\n\n  /**\n   * Generate the subscription string for cached live streams\n   *\n   * @private\n   * @param {String} stream - stream name from which you want to stream\n   * @param {String} type - resource type on which subscribe or publish [exchange/queue]\n   * @return a string that represents the topic name for that channel\n   */\n  _cachedStreamTopicFor(params = {}) {\n    const {\n      stream = undefined, type = this._existingQueuePrefix\n    } = params;\n    const topic = stream;\n    return `/${type}/${topic}.${this._liveStreamSuffix}`;\n  }\n\n  /**\n   * Generate the subscription for live streams without caching\n   *\n   * @private\n   * @param {String} stream - stream name from which you want to stream\n   * @param {String} type - resource type on which subscribe or publish [exchange/queue]\n   * @param {String} routingKey - binding pattern\n   * @return a string that represents the topic name for that channel\n   */\n  _streamTopicFor(params = {}) {\n    const {\n      stream = undefined, type = this._defaultResource, routingKey = this._defaultPattern\n    } = params;\n    const resource = stream;\n    return `/${type}/${resource}.${this._liveStreamSuffix}/${routingKey}`;\n  }\n}\n\n// Remove unwnated methods inherited from StompClient\ndelete StompStreamClient.onReceive;\ndelete StompStreamClient.publish;\ndelete StompStreamClient._subcriptionFor;\ndelete StompStreamClient._destinationFor;\n\nexport default StompStreamClient;\n"],"sourceRoot":"../src"}