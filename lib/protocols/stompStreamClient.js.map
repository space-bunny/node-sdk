{"version":3,"sources":["protocols/stompStreamClient.js"],"names":["require","CONFIG","StompStreamClient","opts","_subscriptions","stompStreamOpts","stomp","stream","_defaultResource","defaultResource","_defaultPattern","defaultPattern","streamHooks","length","Promise","mapSeries","streamHook","_attachStreamHook","reject","Error","subscriptionId","undefined","resolve","isConnected","subscription","unsubscribe","subscriptions","Object","keys","forEach","_stompConnection","disconnect","catch","reason","deviceId","channel","routingKey","topic","cache","emptyFunction","callback","connect","then","client","streamTopic","tempQueue","liveStreamExists","console","error","_cachedStreamTopicFor","_streamTopicFor","_liveStreamSuffix","_streamChannelTopicFor","subscriptionHeaders","messageCallback","message","_parseContent","body","headers","subscribe","id","e","params","type","resource","finalTopic","_existingQueuePrefix","liveStreamByName","StompClient","onReceive","publish","_subcriptionFor","_destinationFor"],"mappings":"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","file":"stompStreamClient.js","sourcesContent":["/**\n * A module that exports an StompStreamClient client\n * which inherits from the Stomp base client\n * @module StompStreamClient\n */\n\n// Import some helpers modules\nimport merge from 'merge';\nimport Promise from 'bluebird';\nimport md5 from 'js-md5';\n\n// Import StompClient main module from which StompStreamClient inherits\nimport StompClient from './stompClient';\n\nconst { CONFIG } = require('../../config/constants');\n\nclass StompStreamClient extends StompClient {\n  /**\n   * @constructor\n   * @param {Object} opts - options must contain client and secret for access keys\n   */\n  constructor(opts) {\n    super(opts);\n    this._subscriptions = {};\n    const stompStreamOpts = CONFIG.stomp.stream;\n    this._defaultResource = CONFIG.stomp.defaultResource;\n    this._defaultPattern = stompStreamOpts.defaultPattern;\n  }\n\n  /**\n   * Subscribe to multiple stream hooks\n   *\n   * @param {Array} streamHooks - Array of objects. Each objects containing\n   * { deviceId: {string}, channel: {string}, callback: {func} }\n   * @param {Object} options - subscription options\n   * @return promise containing the result of multiple subscriptions\n   */\n  streamFrom(streamHooks = [], opts) {\n    if (streamHooks.length > 0) {\n      return Promise.mapSeries(streamHooks, (streamHook) => {\n        return this._attachStreamHook(streamHook, opts);\n      });\n    } else {\n      return Promise.reject(new Error('Missing stream hooks'));\n    }\n  }\n\n  /**\n   * Unsubscribe client from a topic\n   *\n   * @param {String} subscriptionId - subscription ID\n   * @return a promise containing the result of the operation\n   */\n  unsubscribe(subscriptionId = undefined) {\n    return new Promise((resolve, reject) => {\n      if (!this.isConnected()) {\n        reject(new Error('Invalid connection'));\n      } else {\n        const subscription = this._subscriptions[subscriptionId];\n        if (subscription) {\n          subscription.unsubscribe();\n          delete this._subscriptions[subscriptionId];\n          resolve(true);\n        } else {\n          reject(new Error('Subscription not found'));\n        }\n      }\n    });\n  }\n\n  /**\n   * Destroy the connection between the stomp client and broker\n   *\n   * @return a promise containing the result of the operation\n   */\n  disconnect() {\n    return new Promise((resolve, reject) => {\n      if (!this.isConnected()) {\n        reject(new Error('Invalid connection'));\n      } else {\n        const subscriptions = Object.keys(this._subscriptions);\n        subscriptions.forEach((subscription) => {\n          if (this._subscriptions[subscription]) {\n            this._subscriptions[subscription].unsubscribe();\n          }\n        });\n        this._subscriptions = {};\n        this._stompConnection.disconnect(() => {\n          this._stompConnection = undefined;\n          resolve(true);\n        }).catch((reason) => {\n          reject(reason);\n        });\n      }\n    });\n  }\n\n  // ------------ PRIVATE METHODS -------------------\n\n  /**\n   * Start consuming messages from a device's channel\n   * It generates an auto delete queue from which consume\n   * and binds it to the channel exchange\n   *\n   * @private\n   * @param {Object} streamHook - Object containit hook info\n   * { deviceId: {String}, channel: {String}, callback: {func}}\n   * @param {Object} opts - connection options\n   * @return a promise containing current connection\n   */\n  _attachStreamHook(streamHook, opts = {}) {\n    opts = merge({}, opts);\n    return new Promise((resolve, reject) => {\n      // Receive messages from imput queue\n      const {\n        stream = undefined, deviceId = undefined, channel = undefined, routingKey = undefined, topic = undefined\n      } = streamHook;\n      const cache = (typeof (streamHook.cache) !== 'boolean') ? true : streamHook.cache;\n      const emptyFunction = () => { return undefined; };\n      const callback = streamHook.callback || emptyFunction;\n      if (stream === undefined && deviceId === undefined) {\n        reject(new Error('Missing Stream or Device ID'));\n      }\n      this.connect().then((client) => {\n        let streamTopic;\n        let tempQueue;\n        if (stream) {\n          if (!this.liveStreamExists(stream)) {\n            console.error(`Stream ${stream} does not exist`); // eslint-disable-line no-console\n            resolve(false);\n          }\n          if (cache) {\n            // Cached streams are connected to the existing live stream queue\n            streamTopic = this._cachedStreamTopicFor({ stream });\n          } else {\n            // Uncached streams are connected to the stream exchange and create a temp queue\n            streamTopic = this._streamTopicFor({ stream, routingKey, topic });\n            tempQueue = this.tempQueue(stream, this._liveStreamSuffix);\n          }\n        } else {\n          // else if current hook is channel (or a couple deviceId, channel)\n          // creates a temp queue, binds to channel exchange and starts consuming\n          streamTopic = this._streamChannelTopicFor({\n            deviceId, channel, routingKey, topic\n          });\n          tempQueue = this.tempQueue(deviceId, channel);\n        }\n        const subscriptionHeaders = {};\n        if (tempQueue) { subscriptionHeaders['x-queue-name'] = tempQueue; }\n        const messageCallback = (message) => {\n          callback(this._parseContent(message.body), message.headers);\n        };\n        try {\n          const subscriptionId = md5(`${tempQueue}-${streamTopic}`);\n          const subscription = client.subscribe(streamTopic, messageCallback, {\n            ...subscriptionHeaders,\n            id: subscriptionId\n          });\n          this._subscriptions[subscriptionId] = subscription;\n          resolve(merge(streamHook, { id: subscriptionId }));\n        } catch (e) {\n          console.error(e); // eslint-disable-line no-console\n          resolve(undefined);\n        }\n      }).catch((reason) => {\n        console.error(reason); // eslint-disable-line no-console\n        resolve(undefined);\n      });\n    });\n  }\n\n  /**\n   * Generate the subscription string for a specific channel\n   *\n   * @private\n   * @param {String} deviceId - deviceId from which you want to stream from\n   * @param {String} channel - channel name from which you want to stream from\n   * @param {String} type - resource type on which subscribe or publish [exchange/queue]\n   * @param {String} routingKey - binding pattern\n   * @return a string that represents the topic name for that channel\n   */\n  _streamChannelTopicFor(params = {}) {\n    const {\n      deviceId = undefined, channel = undefined, type = this._defaultResource,\n      routingKey = this._defaultPattern, topic = undefined\n    } = params;\n    let resource = deviceId;\n    if (channel) {\n      resource += `.${channel}`;\n    }\n    let finalTopic = resource;\n    if (topic) {\n      finalTopic += `.${topic}`;\n    } else {\n      finalTopic = routingKey;\n    }\n    return `/${type}/${resource}/${finalTopic}`;\n  }\n\n  /**\n   * Generate the subscription string for cached live streams\n   *\n   * @private\n   * @param {String} stream - stream name from which you want to stream\n   * @param {String} type - resource type on which subscribe or publish [exchange/queue]\n   * @return a string that represents the topic name for that channel\n   */\n  _cachedStreamTopicFor(params = {}) {\n    const {\n      stream = undefined, type = this._existingQueuePrefix\n    } = params;\n    const topic = this.liveStreamByName(stream);\n    return `/${type}/${topic}.${this._liveStreamSuffix}`;\n  }\n\n  /**\n   * Generate the subscription for live streams without caching\n   *\n   * @private\n   * @param {String} stream - stream name from which you want to stream\n   * @param {String} type - resource type on which subscribe or publish [exchange/queue]\n   * @param {String} routingKey - binding pattern\n   * @return a string that represents the topic name for that channel\n   */\n  _streamTopicFor(params = {}) {\n    const {\n      stream = undefined, type = this._defaultResource, routingKey = this._defaultPattern\n    } = params;\n    const resource = this.liveStreamByName(stream);\n    return `/${type}/${resource}.${this._liveStreamSuffix}/${routingKey}`;\n  }\n}\n\n// Remove unwnated methods inherited from StompClient\ndelete StompStreamClient.onReceive;\ndelete StompStreamClient.publish;\ndelete StompStreamClient._subcriptionFor;\ndelete StompStreamClient._destinationFor;\n\nexport default StompStreamClient;\n"],"sourceRoot":"../src"}