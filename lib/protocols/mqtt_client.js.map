{"version":3,"sources":["mqtt_client.js"],"names":[],"mappings":"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","file":"protocols/mqtt_client.js","sourcesContent":["/**\n * A module that exports an MqttClient client\n * which inherits from the SpaceBunny base client\n * @module MqttClient\n */\n\n// Import some helpers modules\nimport merge from 'merge';\nimport Promise from 'bluebird';\n\n// Import mqtt library\nimport mqtt from 'mqtt';\n\n// Import SpaceBunny main module from which MqttClient inherits\nimport SpaceBunny from '../spacebunny';\n\n/**\n * @constructor\n * @param {Object} opts - constructor options may contain api-key or connection options\n */\nclass MqttClient extends SpaceBunny {\n\n  constructor(opts) {\n    super(opts);\n    this._protocol = 'mqtt';\n    this._client = undefined;\n    this._connectionOpts = { qos: 1 };\n    this._connectTimeout = 5000;\n    this.connection();\n  }\n\n  /**\n   * Subscribe to input channel\n   *\n   * @param {function} callback - function called every time a message is receviced\n   * passing the current message as argument\n   * @param {Object} options - subscription options\n   * @return promise containing the result of the subscription\n   */\n  onReceive(callback, opts) {\n    // subscribe for input messages\n    return new Promise((resolve, reject) => {\n      this._connect().then((client) => {\n        client.subscribe(this._topicFor(this._inputTopic), merge(this._connectionOpts, opts), function(err) {\n          if (err) {\n            reject(false);\n          } else {\n            client.on('message', function(topic, message) {\n              callback(topic, message);\n            });\n            resolve(true);\n          }\n        });\n      }).catch(function(reason) {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Publish a message on a specific channel\n   *\n   * @param {String} channel - channel name on which you want to publish a message\n   * @param {Object} message - the message payload\n   * @param {Object} message - the message payload\n   * @return promise containing true if the\n   */\n  publish(channel, message, opts) {\n    // Publish message\n    return new Promise((resolve, reject) => {\n      this._connect().then((client) => {\n        client.on('connect', () => {\n          const bufferedMessage = new Buffer(this._encapsulateContent(message));\n          client.publish(this._topicFor(channel), bufferedMessage, merge(this._connectionOpts, opts), function() {\n            resolve(true);\n          });\n        });\n      }).catch(function(reason) {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Destroy the connection between the mqtt client and broker\n   *\n   * @return a promise containing the result of the operation\n   */\n  disconnect() {\n    return new Promise((resolve, reject) => {\n      if (this._client === undefined) {\n        reject('Invalid connection');\n      } else {\n        this._client.end().then(function() {\n          resolve(true);\n        }).catch(function(reason) {\n          reject(reason);\n        });\n      }\n    });\n  }\n\n  // ------------ PRIVATE METHODS -------------------\n\n  /**\n   * @private\n   * Establish an mqtt connection with the broker\n   * using configurations retrieved from the endpoint\n   *\n   * @param {Object} opts - connection options\n   * @return a promise containing current connection\n   */\n  _connect(opts) {\n    opts = merge({}, opts);\n    const connectionParams = this._connectionParams;\n\n    return new Promise((resolve, reject) => {\n      if (this._client !== undefined) {\n        resolve(this._client);\n      } else {\n        try {\n          const client = mqtt.connect({\n            host: connectionParams.host,\n            port: connectionParams.protocols.mqtt.port,\n            username: `${connectionParams.vhost}:${connectionParams.deviceId}`,\n            password: connectionParams.secret,\n            clientId: connectionParams.deviceId,\n            connectTimeout: opts.connectTimeout || this._connectTimeout\n          });\n          client.on('error', function(reason) {\n            reject(reason);\n          });\n          client.on('close', function(reason) {\n            reject(reason);\n          });\n          this._client = client;\n          resolve(this._client);\n        } catch (reason) {\n          reject(reason);\n        }\n      }\n    });\n  }\n\n  /**\n   * @private\n   * Generate the topic for a specific channel\n   *\n   * @param {String} channel - channel name on which you want to publish a message\n   * @return a string that represents the topic name for that channel\n   */\n  _topicFor(channel) {\n    return this.deviceId().concat('/', channel);\n  }\n}\n\nexport default MqttClient;\n"],"sourceRoot":"/Users/gfoiani/Dev/work/spacebunny/sdk-node/src"}