{"version":3,"sources":["protocols/mqttStreamClient.js"],"names":["MqttStreamClient","streamHooks","opts","Promise","resolve","reject","connect","then","mqttClient","emptyFunction","undefined","forEach","streamHook","stream","deviceId","channel","qos","cache","liveStreamExists","console","error","_topics","_streamTopicFor","_streamChannelTopicFor","_connectionOpts","subscribe","err","on","topic","message","splitted","split","streams","filter","liveStreamByName","callback","length","_parseContent","catch","reason","_liveStreamSuffix","MqttClient","onReceive","publish","_topicFor"],"mappings":"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","file":"protocols/mqttStreamClient.js","sourcesContent":["/**\n * A module that exports an MqttStreamClient client\n * which inherits from the Mqtt base client\n * @module MqttStreamClient\n */\n\n// Import some helpers modules\nimport merge from 'merge';\nimport Promise from 'bluebird';\n\n// Import MqttClient main module from which MqttStreamClient inherits\nimport MqttClient from './mqttClient';\n\nclass MqttStreamClient extends MqttClient {\n\n  /**\n   * Subscribe to multiple stream hooks\n   *\n   * @param {Array} streamHooks - Array of objects. Each objects containing\n   * { deviceId: {string}, channel: {string}, callback: {func} }\n   * @param {Object} options - subscription options\n   * @return promise containing the result of multiple subscriptions\n   */\n  streamFrom(streamHooks = [], opts) {\n    return new Promise((resolve, reject) => {\n      this.connect().then((mqttClient) => {\n        const emptyFunction = () => { return undefined; };\n        streamHooks.forEach((streamHook) => {\n          const stream = streamHook.stream;\n          const deviceId = streamHook.deviceId;\n          const channel = streamHook.channel;\n          const qos = streamHook.qos;\n          const cache = (typeof(streamHook.cache) !== 'boolean') ? true : streamHook.cache;\n          if (stream === undefined && (channel === undefined || deviceId === undefined)) {\n            reject('Missing Stream or Device ID and Channel');\n          }\n          if (stream) {\n            if (!this.liveStreamExists(stream)) {\n              console.error(`Stream ${stream} does not exist`); // eslint-disable-line no-console\n              resolve(false);\n            }\n            // Cached streams generate qos1 connections with persistent queues\n            // Uncached streams generate qos0 connections with auto delete queues\n            this._topics[this._streamTopicFor(stream)] = (cache) ? 1 : 0;\n          } else {\n            // streams connected directly to a specific channel generate qos0 connections with auto delete queues\n            this._topics[this._streamChannelTopicFor(deviceId, channel)] = qos || this._connectionOpts.qos;\n          }\n        });\n        mqttClient.subscribe(this._topics, merge(this._connectionOpts, opts), (err) => {\n          if (err) {\n            reject(false);\n          } else {\n            mqttClient.on('message', (topic, message) => {\n              const splitted = topic.split('/');\n              const streams = streamHooks.filter((streamHook) => {\n                return this.liveStreamByName(streamHook.stream) === splitted[0] ||\n                  (streamHook.deviceId === splitted[0] && streamHook.channel === splitted[1]);\n              });\n              let callback = emptyFunction;\n              if (streams.length > 0) {\n                callback = streams[0].callback || emptyFunction;\n              }\n              callback(topic, this._parseContent(message));\n            });\n            resolve(true);\n          }\n        });\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  // ------------ PRIVATE METHODS -------------------\n\n  /**\n   * Generate the topic for a specific channel\n   *\n   * @private\n   * @param {String} deviceId - deviceId from which you want to stream\n   * @param {String} channel - channel name from which you want to stream\n   * @return a string that represents the topic name for that channel\n   */\n  _streamChannelTopicFor(deviceId, channel) {\n    return `${deviceId}/${channel}`;\n  }\n\n  /**\n   * Generate the topic for a specific stream\n   *\n   * @private\n   * @param {String} streamName - stream name from which you want to stream\n   * @return a string that represents the topic name for that stream\n   */\n  _streamTopicFor(stream) {\n    return `${this.liveStreamByName(stream)}/${this._liveStreamSuffix}`;\n  }\n}\n\n// Remove unwnated methods inherited from MqttClient\ndelete MqttStreamClient.onReceive;\ndelete MqttStreamClient.publish;\ndelete MqttStreamClient._topicFor;\n\nexport default MqttStreamClient;\n"],"sourceRoot":"./src"}