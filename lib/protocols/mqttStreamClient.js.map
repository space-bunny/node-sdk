{"version":3,"sources":["protocols/mqttStreamClient.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAeM;;;;;;;;AAMJ,WANI,gBAMJ,CAAY,IAAZ,EAAkB;0BANd,kBAMc;;kEANd,6BAOI,OADU;GAAlB;;;;;;;;;;;eANI;;+BAkBO,aAAa,MAAM;;;AAC5B,UAAM,gBAAgB,SAAhB,aAAgB,GAAW;AAAE,eAAO,SAAP,CAAF;OAAX,CADM;AAE5B,kBAAY,OAAZ,CAAoB,UAAC,UAAD,EAAgB;AAClC,YAAM,SAAS,WAAW,MAAX,CADmB;AAElC,YAAM,WAAW,WAAW,QAAX,CAFiB;AAGlC,YAAM,UAAU,WAAW,OAAX,CAHkB;AAIlC,YAAM,MAAM,WAAW,GAAX,CAJsB;AAKlC,YAAI,WAAW,SAAX,KAAyB,YAAY,SAAZ,IAAyB,aAAa,SAAb,CAAlD,EAA2E;AAC7E,gBAAM,IAAI,2BAAiB,2BAAjB,CAA6C,yCAAjD,CAAN,CAD6E;SAA/E;AAGA,YAAI,MAAJ,EAAY;AACV,iBAAK,OAAL,CAAa,OAAK,eAAL,CAAqB,MAArB,CAAb,IAA6C,OAAO,OAAK,eAAL,CAAqB,GAArB,CAD1C;SAAZ,MAEO;AACL,iBAAK,OAAL,CAAa,OAAK,sBAAL,CAA4B,QAA5B,EAAsC,OAAtC,CAAb,IAA+D,OAAO,OAAK,eAAL,CAAqB,GAArB,CADjE;SAFP;OARkB,CAApB,CAF4B;AAgB5B,aAAO,uBAAY,UAAC,OAAD,EAAU,MAAV,EAAqB;AACtC,eAAK,QAAL,GAAgB,IAAhB,CAAqB,UAAC,UAAD,EAAgB;AACnC,qBAAW,SAAX,CAAqB,OAAK,OAAL,EAAc,qBAAM,OAAK,eAAL,EAAsB,IAA5B,CAAnC,EAAsE,UAAC,GAAD,EAAS;AAC7E,gBAAI,GAAJ,EAAS;AACP,qBAAO,KAAP,EADO;aAAT,MAEO;AACL,sBAAQ,GAAR,qBAA8B,oBAAK,OAAK,OAAL,CAAnC;AADK,wBAEL,CAAW,EAAX,CAAc,SAAd,EAAyB,UAAS,KAAT,EAAgB,OAAhB,EAAyB;AAChD,oBAAM,WAAW,MAAM,KAAN,CAAY,GAAZ,CAAX,CAD0C;AAEhD,oBAAM,WAAW,YAAY,MAAZ,CAAmB,UAAS,UAAT,EAAqB;AACvD,yBAAO,WAAW,MAAX,KAAsB,SAAS,CAAT,CAAtB,IAAsC,WAAW,QAAX,KAAwB,SAAS,CAAT,CAAxB,IAAuC,WAAW,OAAX,KAAuB,SAAS,CAAT,CAAvB,CAD7B;iBAArB,CAAnB,CAEd,CAFc,EAEX,QAFW,IAEC,aAFD,CAF+B;AAKhD,yBAAS,KAAT,EAAgB,OAAhB,EALgD;eAAzB,CAAzB,CAFK;AASL,sBAAQ,IAAR,EATK;aAFP;WADoE,CAAtE,CADmC;SAAhB,CAArB,CAgBG,KAhBH,CAgBS,UAAS,MAAT,EAAiB;AACxB,iBAAO,MAAP,EADwB;SAAjB,CAhBT,CADsC;OAArB,CAAnB,CAhB4B;;;;;;;;;;;;;;;;2CAiDP,UAAU,SAAS;AACxC,aAAU,iBAAY,OAAtB,CADwC;;;;;;;;;;;;;oCAW1B,QAAQ;AACtB,aAAU,eAAU,KAAK,iBAAL,CADE;;;;SA9EpB;;;;;AAoFN,OAAO,iBAAiB,SAAjB;AACP,OAAO,iBAAiB,OAAjB;AACP,OAAO,iBAAiB,SAAjB;;kBAEQ","file":"protocols/mqttStreamClient.js","sourcesContent":["/**\n * A module that exports an MqttStreamClient client\n * which inherits from the Mqtt base client\n * @module MqttStreamClient\n */\n\n// Import some helpers modules\nimport merge from 'merge';\nimport Promise from 'bluebird';\n\n// Import MqttClient main module from which MqttStreamClient inherits\nimport MqttClient from './mqttClient';\nimport SpaceBunnyErrors from '../spacebunnyErrors';\nimport { keys } from 'lodash';\n\nclass MqttStreamClient extends MqttClient {\n\n  /**\n   * @constructor\n   * @param {Object} opts - options must contain client and secret for access keys\n   */\n  constructor(opts) {\n    super(opts);\n  }\n\n  /**\n   * Subscribe to multiple stream hooks\n   *\n   * @param {Array} streamHooks - Array of objects. Each objects containing\n   * { deviceId: {string}, channel: {string}, callback: {func} }\n   * @param {Object} options - subscription options\n   * @return promise containing the result of multiple subscriptions\n   */\n  streamFrom(streamHooks, opts) {\n    const emptyFunction = function() { return undefined; };\n    streamHooks.forEach((streamHook) => {\n      const stream = streamHook.stream;\n      const deviceId = streamHook.deviceId;\n      const channel = streamHook.channel;\n      const qos = streamHook.qos;\n      if (stream === undefined && (channel === undefined || deviceId === undefined)) {\n        throw new SpaceBunnyErrors.MissingStreamConfigurations('Missing Stream or Device ID and Channel');\n      }\n      if (stream) {\n        this._topics[this._streamTopicFor(stream)] = qos || this._connectionOpts.qos;\n      } else {\n        this._topics[this._streamChannelTopicFor(deviceId, channel)] = qos || this._connectionOpts.qos;\n      }\n    });\n    return new Promise((resolve, reject) => {\n      this._connect().then((mqttClient) => {\n        mqttClient.subscribe(this._topics, merge(this._connectionOpts, opts), (err) => {\n          if (err) {\n            reject(false);\n          } else {\n            console.log(`streaming from ${keys(this._topics)}`); // eslint-disable-line no-console\n            mqttClient.on('message', function(topic, message) {\n              const splitted = topic.split('/');\n              const callback = streamHooks.filter(function(streamHook) {\n                return streamHook.stream === splitted[0] || (streamHook.deviceId === splitted[0] && streamHook.channel === splitted[1]);\n              })[0].callback || emptyFunction;\n              callback(topic, message);\n            });\n            resolve(true);\n          }\n        });\n      }).catch(function(reason) {\n        reject(reason);\n      });\n    });\n  }\n\n  // ------------ PRIVATE METHODS -------------------\n\n  /**\n   * Generate the topic for a specific channel\n   *\n   * @private\n   * @param {String} deviceId - deviceId from which you want to stream\n   * @param {String} channel - channel name from which you want to stream\n   * @return a string that represents the topic name for that channel\n   */\n  _streamChannelTopicFor(deviceId, channel) {\n    return `${deviceId}/${channel}`;\n  }\n\n  /**\n   * Generate the topic for a specific stream\n   *\n   * @private\n   * @param {String} stream - stream identifier\n   * @return a string that represents the topic name for that stream\n   */\n  _streamTopicFor(stream) {\n    return `${stream}/${this._liveStreamSuffix}`;\n  }\n}\n\n// Remove unwnated methods inherited from MqttClient\ndelete MqttStreamClient.onReceive;\ndelete MqttStreamClient.publish;\ndelete MqttStreamClient._topicFor;\n\nexport default MqttStreamClient;\n"],"sourceRoot":"/Users/gfoiani/Dev/work/spacebunny/sdk-node/src"}