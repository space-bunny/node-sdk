{"version":3,"sources":["protocols/mqttStreamClient.js"],"names":["MqttStreamClient","streamHooks","opts","Promise","resolve","reject","connect","then","mqttClient","emptyFunction","undefined","forEach","streamHook","stream","deviceId","channel","qos","cache","Error","liveStreamExists","console","error","_topics","_streamTopicFor","_streamChannelTopicFor","_connectionOpts","localOpts","subscribe","err","on","topic","message","splitted","split","streams","filter","callback","length","_parseContent","catch","reason","_liveStreamSuffix","MqttClient","onReceive","publish","_topicFor"],"mappings":"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","file":"mqttStreamClient.js","sourcesContent":["/**\n * A module that exports an MqttStreamClient client\n * which inherits from the Mqtt base client\n * @module MqttStreamClient\n */\n\n// Import some helpers modules\nimport _ from 'lodash';\nimport Promise from 'bluebird';\n\n// Import MqttClient main module from which MqttStreamClient inherits\nimport MqttClient from './mqttClient';\n\nclass MqttStreamClient extends MqttClient {\n  /**\n   * Subscribe to multiple stream hooks\n   *\n   * @param {Array} streamHooks - Array of objects. Each objects containing\n   * { deviceId: {string}, channel: {string}, callback: {func} }\n   * @param {Object} options - subscription options\n   * @return promise containing the result of multiple subscriptions\n   */\n  streamFrom(streamHooks = [], opts = {}) {\n    return new Promise((resolve, reject) => {\n      this.connect().then((mqttClient) => {\n        const emptyFunction = () => { return undefined; };\n        streamHooks.forEach((streamHook) => {\n          const stream = streamHook.stream;\n          const deviceId = streamHook.deviceId;\n          const channel = streamHook.channel;\n          const qos = streamHook.qos;\n          const cache = (typeof streamHook.cache !== 'boolean') ? true : streamHook.cache;\n          if (stream === undefined && (channel === undefined || deviceId === undefined)) {\n            reject(new Error('Missing Stream or Device ID and Channel'));\n          }\n          if (stream) {\n            if (!this.liveStreamExists(stream)) {\n              console.error(`Stream ${stream} does not exist`); // eslint-disable-line no-console\n              resolve(false);\n            }\n            // Cached streams generate qos1 connections with persistent queues\n            // Uncached streams generate qos0 connections with auto delete queues\n            this._topics[this._streamTopicFor(stream)] = (cache) ? 1 : 0;\n          } else {\n            // streams connected directly to a specific channel generate qos0 connections with auto delete queues\n            this._topics[this._streamChannelTopicFor(deviceId, channel)] = qos || this._connectionOpts.qos;\n          }\n        });\n        let localOpts = _.cloneDeep(opts);\n        localOpts = _.merge(this._connectionOpts, localOpts);\n        mqttClient.subscribe(this._topics, localOpts, (err) => {\n          if (err) {\n            reject(err);\n          } else {\n            mqttClient.on('message', (topic, message) => {\n              const splitted = topic.split('/');\n              const streams = streamHooks.filter((streamHook) => {\n                return streamHook.stream === splitted[0]\n                  || (streamHook.deviceId === splitted[0] && streamHook.channel === splitted[1]);\n              });\n              let callback = emptyFunction;\n              if (streams.length > 0) {\n                callback = streams[0].callback || emptyFunction;\n              }\n              callback(topic, this._parseContent(message));\n            });\n            resolve(true);\n          }\n        });\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  // ------------ PRIVATE METHODS -------------------\n\n  /**\n   * Generate the topic for a specific channel\n   *\n   * @private\n   * @param {String} deviceId - deviceId from which you want to stream\n   * @param {String} channel - channel name from which you want to stream\n   * @return a string that represents the topic name for that channel\n   */\n  _streamChannelTopicFor(deviceId, channel) {\n    return `${deviceId}/${channel}`;\n  }\n\n  /**\n   * Generate the topic for a specific stream\n   *\n   * @private\n   * @param {String} streamName - stream name from which you want to stream\n   * @return a string that represents the topic name for that stream\n   */\n  _streamTopicFor(stream) {\n    return `${stream}/${this._liveStreamSuffix}`;\n  }\n}\n\n// Remove unwnated methods inherited from MqttClient\ndelete MqttStreamClient.onReceive;\ndelete MqttStreamClient.publish;\ndelete MqttStreamClient._topicFor;\n\nexport default MqttStreamClient;\n"],"sourceRoot":"../src"}