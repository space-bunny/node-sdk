{"version":3,"sources":["protocols/amqpStreamClient.js"],"names":["require","CONFIG","AmqpStreamClient","opts","amqpStreamOptions","amqp","stream","_defaultStreamRoutingKey","defaultStreamRoutingKey","_streamQueueArguments","streamQueueArguments","_subscriptions","streamHooks","length","Promise","mapSeries","streamHook","_attachStreamHook","reject","Error","resolve","undefined","deviceId","channel","topic","cache","routingKey","emptyFunction","callback","currentTime","Date","getTime","tempQueue","_createChannel","then","ch","_amqpChannels","promisesChain","liveStreamExists","console","error","_cachedStreamQueue","checkQueue","consume","message","_parseContent","content","fields","properties","_subscribeArgs","streamExchange","exchangeName","_liveStreamSuffix","checkExchange","assertQueue","bindQueue","channelExchangeName","_streamRoutingKeyFor","subscriptionId","amqpChannel","id","catch","reason","isConnected","subscription","close","streamName","params","streamRoutingKey","AmqpClient","onReceive","publish","_routingKeyFor"],"mappings":"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","file":"amqpStreamClient.js","sourcesContent":["/**\n * A module that exports an AmqpStreamClient client\n * which inherits from the Amqp base client\n * @module AmqpStreamClient\n */\n\n// Import some helpers modules\nimport merge from 'merge';\nimport Promise from 'bluebird';\nimport md5 from 'js-md5';\n\n// Import AmqpClient module from which AmqpStreamClient inherits\nimport AmqpClient from './amqpClient';\n\nconst { CONFIG } = require('../../config/constants');\n\nclass AmqpStreamClient extends AmqpClient {\n  /**\n   * @constructor\n   * @param {Object} opts - options must contain client and secret for access keys\n   */\n  constructor(opts) {\n    super(opts);\n    const amqpStreamOptions = CONFIG.amqp.stream;\n    this._defaultStreamRoutingKey = amqpStreamOptions.defaultStreamRoutingKey;\n    this._streamQueueArguments = amqpStreamOptions.streamQueueArguments;\n    this._subscriptions = [];\n  }\n\n  /**\n   * Subscribe to multiple stream hooks\n   *\n   * @param {Array} streamHooks - Array of objects. Each objects containing\n   * { deviceId: {string}, channel: {string}, callback: {func} }\n   * @param {Object} options - subscription options\n   * @return promise containing the result of multiple subscriptions\n   */\n  streamFrom(streamHooks = [], opts) {\n    if (streamHooks.length > 0) {\n      return Promise.mapSeries(streamHooks, (streamHook) => {\n        return this._attachStreamHook(streamHook, opts);\n      });\n    } else {\n      return Promise.reject(new Error('Missing stream hooks'));\n    }\n  }\n\n  // ------------ PRIVATE METHODS -------------------\n\n  /**\n   * Start consuming messages from a device's channel\n   * It generates an auto delete queue from which consume\n   * and binds it to the channel exchange\n   *\n   * @private\n   * @param {Object} streamHook - Object containit hook info\n   * { stream: {String}, callback: {func}}\n   * or\n   * { deviceId: {String}, channel: {String}, callback: {func}}\n   * @param {Object} opts - connection options\n   * @return a promise containing current connection\n   */\n  _attachStreamHook(streamHook, opts) {\n    // Receive messages from imput queue\n    return new Promise((resolve, reject) => {\n      const {\n        stream = undefined, deviceId = undefined, channel = undefined, topic = undefined\n      } = streamHook;\n      const cache = (typeof (streamHook.cache) !== 'boolean') ? true : streamHook.cache;\n      if (stream === undefined && (channel === undefined || deviceId === undefined)) {\n        reject(new Error('Missing Stream or Device ID and Channel'));\n      }\n      const routingKey = streamHook.routingKey || this._defaultStreamRoutingKey;\n      const emptyFunction = function () { return undefined; };\n      const callback = streamHook.callback || emptyFunction;\n\n      const currentTime = new Date().getTime();\n      let tempQueue;\n      this._createChannel(`${currentTime}`).then((ch) => {\n        this._amqpChannels[`${currentTime}`] = ch;\n        let promisesChain;\n        // if current hook is a stream\n        // checks the existence of the stream queue and starts consuming\n        if (stream) {\n          if (!this.liveStreamExists(stream)) {\n            console.error(`Stream ${stream} does not exist`); // eslint-disable-line no-console\n            resolve(false);\n          }\n          if (cache) {\n            // Cached streams are connected to the existing live stream queue\n            tempQueue = this._cachedStreamQueue(stream);\n            promisesChain = this._amqpChannels[`${currentTime}`]\n              .checkQueue(tempQueue, this._streamQueueArguments).then(() => {\n                return this._amqpChannels[`${currentTime}`].consume(tempQueue, (message) => {\n                  // Call message callback\n                  callback(this._parseContent(message.content), message.fields, message.properties);\n                }, merge(this._subscribeArgs, opts));\n              });\n          } else {\n            // Uncached streams are connected to the stream exchange and create a temp queue\n            const streamExchange = this.exchangeName(stream, this._liveStreamSuffix);\n            tempQueue = this.tempQueue(stream, this._liveStreamSuffix, currentTime);\n            promisesChain = this._amqpChannels[`${currentTime}`].checkExchange(streamExchange).then(() => {\n              return this._amqpChannels[`${currentTime}`].assertQueue(tempQueue, this._streamQueueArguments);\n            }).then(() => {\n              return this._amqpChannels[`${currentTime}`].bindQueue(tempQueue, streamExchange, routingKey);\n            }).then(() => {\n              return this._amqpChannels[`${currentTime}`].consume(tempQueue, (message) => {\n                callback(this._parseContent(message.content), message.fields, message.properties);\n              }, merge(this._subscribeArgs, opts));\n            });\n          }\n        } else {\n          // else if current hook is channel (or a couple deviceId, channel)\n          // creates a temp queue, binds to channel exchange and starts consuming\n          const channelExchangeName = this.exchangeName(deviceId, channel);\n          tempQueue = this.tempQueue(deviceId, channel, currentTime);\n          promisesChain = this._amqpChannels[`${currentTime}`].checkExchange(channelExchangeName).then(() => {\n            return this._amqpChannels[`${currentTime}`].assertQueue(tempQueue, this._streamQueueArguments);\n          }).then(() => {\n            return this._amqpChannels[`${currentTime}`].bindQueue(tempQueue, channelExchangeName,\n              this._streamRoutingKeyFor({\n                deviceId, channel, routingKey, topic\n              }));\n          }).then(() => {\n            return this._amqpChannels[`${currentTime}`].consume(tempQueue, (message) => {\n              callback(this._parseContent(message.content), message.fields, message.properties);\n            }, merge(this._subscribeArgs, opts));\n          });\n        }\n        return promisesChain;\n      }).then(() => {\n        const subscriptionId = md5(tempQueue);\n        this._subscriptions[subscriptionId] = { amqpChannel: currentTime };\n        resolve(merge(streamHook, { id: subscriptionId }));\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Unsubscribe client from a topic\n   *\n   * @param {String} subscriptionId - subscription ID\n   * @return a promise containing the result of the operation\n   */\n  unsubscribe(subscriptionId = undefined) {\n    return new Promise((resolve, reject) => {\n      if (!this.isConnected()) {\n        reject(new Error('Invalid connection'));\n      } else {\n        const subscription = this._subscriptions[subscriptionId];\n        if (subscription) {\n          const { amqpChannel } = subscription;\n          if (this._amqpChannels[amqpChannel]) {\n            this._amqpChannels[amqpChannel].close();\n            delete this._amqpChannels[amqpChannel];\n            delete this._subscriptions[subscriptionId];\n          }\n          resolve(true);\n        } else {\n          reject(new Error('Subscription not found'));\n        }\n      }\n    });\n  }\n\n  /**\n   * Generate the exchange name for a device's channel\n   *\n   * @private\n   * @param {String} streamName - stream name from which you want to stream\n   * @return a string that represents the stream queue\n   */\n  _cachedStreamQueue(streamName) {\n    return `${streamName}.${this._liveStreamSuffix}`;\n  }\n\n  /**\n   * Generate the exchange name for a device's channel\n   *\n   * @private\n   * @param {Object} params - params\n   * @return a string that represents the rounting key\n   */\n  _streamRoutingKeyFor(params = {}) {\n    const {\n      deviceId = undefined, channel = undefined, routingKey = this._defaultStreamRoutingKey, topic = undefined\n    } = params;\n    if (routingKey) {\n      return routingKey;\n    } else {\n      let streamRoutingKey = deviceId;\n      if (channel) { streamRoutingKey += `.${channel}`; }\n      if (topic) { streamRoutingKey += `.${topic}`; }\n      return `${streamRoutingKey}`;\n    }\n  }\n}\n\n// Remove unwanted methods inherited from AmqpClient\ndelete AmqpStreamClient.onReceive;\ndelete AmqpStreamClient.publish;\ndelete AmqpStreamClient._routingKeyFor;\n\nexport default AmqpStreamClient;\n"],"sourceRoot":"../src"}