{"version":3,"sources":["protocols/amqpStreamClient.js"],"names":["CONFIG","require","AmqpStreamClient","opts","amqpStreamOptions","amqp","stream","_defaultStreamRoutingKey","defaultStreamRoutingKey","_streamQueueArguments","streamQueueArguments","streamHooks","promises","map","streamHook","_attachStreamHook","length","Promise","any","reject","resolve","deviceId","channel","cache","undefined","routingKey","emptyFunction","callback","currentTime","Date","getTime","_createChannel","then","ch","_amqpChannels","promisesChain","liveStreamExists","console","error","cachedStreamQueue","_cachedStreamQueue","checkQueue","consume","message","_parseContent","content","fields","properties","_subscribeArgs","streamExchange","exchangeName","_liveStreamSuffix","streamChannelQueue","tempQueue","checkExchange","assertQueue","bindQueue","channelExchangeName","catch","reason","streamName","liveStreamByName","AmqpClient","onReceive","publish","_routingKeyFor"],"mappings":"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","file":"protocols/amqpStreamClient.js","sourcesContent":["/**\n * A module that exports an AmqpStreamClient client\n * which inherits from the Amqp base client\n * @module AmqpStreamClient\n */\n\n// Import some helpers modules\nimport merge from 'merge';\nimport Promise from 'bluebird';\n\n// Import AmqpClient module from which AmqpStreamClient inherits\nimport AmqpClient from './amqpClient';\n\nconst CONFIG = require('../../config/constants').CONFIG;\n\nclass AmqpStreamClient extends AmqpClient {\n\n  /**\n   * @constructor\n   * @param {Object} opts - options must contain client and secret for access keys\n   */\n  constructor(opts) {\n    super(opts);\n    const amqpStreamOptions = CONFIG.amqp.stream;\n    this._defaultStreamRoutingKey = amqpStreamOptions.defaultStreamRoutingKey;\n    this._streamQueueArguments = amqpStreamOptions.streamQueueArguments;\n  }\n\n  /**\n   * Subscribe to multiple stream hooks\n   *\n   * @param {Array} streamHooks - Array of objects. Each objects containing\n   * { deviceId: {string}, channel: {string}, callback: {func} }\n   * @param {Object} options - subscription options\n   * @return promise containing the result of multiple subscriptions\n   */\n  streamFrom(streamHooks = [], opts) {\n    const promises = streamHooks.map((streamHook) => {\n      return this._attachStreamHook(streamHook, opts);\n    }) || [];\n    if (promises.length > 0) {\n      return Promise.any(promises);\n    } else {\n      return Promise.reject('Missing stream hooks');\n    }\n  }\n\n  // ------------ PRIVATE METHODS -------------------\n\n  /**\n   * Start consuming messages from a device's channel\n   * It generates an auto delete queue from which consume\n   * and binds it to the channel exchange\n   *\n   * @private\n   * @param {Object} streamHook - Object containit hook info\n   * { deviceId: {String}, channel: {String}, callback: {func}}\n   * @param {Object} opts - connection options\n   * @return a promise containing current connection\n   */\n  _attachStreamHook(streamHook, opts) {\n    // Receive messages from imput queue\n    return new Promise((resolve, reject) => {\n      const deviceId = streamHook.deviceId;\n      const channel = streamHook.channel;\n      const stream = streamHook.stream;\n      const cache = (typeof(streamHook.cache) !== 'boolean') ? true : streamHook.cache;\n      if (stream === undefined && (channel === undefined || deviceId === undefined)) {\n        reject('Missing Stream or Device ID and Channel');\n      }\n      const routingKey = streamHook.routingKey || this._defaultStreamRoutingKey;\n      const emptyFunction = function () { return undefined; };\n      const callback = streamHook.callback || emptyFunction;\n\n      const currentTime = new Date().getTime();\n      this._createChannel(`${currentTime}`).then((ch) => {\n        this._amqpChannels[`${currentTime}`] = ch;\n        let promisesChain = undefined;\n        // if current hook is a stream\n        // checks the existence of the stream queue and starts consuming\n        if (stream) {\n          if (!this.liveStreamExists(stream)) {\n            console.error(`Stream ${stream} does not exist`); // eslint-disable-line no-console\n            resolve(false);\n          }\n          if (cache) {\n            // Cached streams are connected to the existing live stream queue\n            const cachedStreamQueue = this._cachedStreamQueue(stream);\n            promisesChain = this._amqpChannels[`${currentTime}`]\n              .checkQueue(cachedStreamQueue, this._streamQueueArguments).then(() => {\n                return this._amqpChannels[`${currentTime}`].consume(cachedStreamQueue, (message) => {\n                  // Call message callback\n                  callback(this._parseContent(message.content), message.fields, message.properties);\n                }, merge(this._subscribeArgs, opts));\n              });\n          } else {\n            // Uncached streams are connected to the stream exchange and create a temp queue\n            const streamExchange = this.exchangeName(stream, this._liveStreamSuffix);\n            const streamChannelQueue = this.tempQueue(stream, this._liveStreamSuffix, currentTime);\n            promisesChain = this._amqpChannels[`${currentTime}`].checkExchange(streamExchange).then(() => {\n              return this._amqpChannels[`${currentTime}`].assertQueue(streamChannelQueue, this._streamQueueArguments);\n            }).then(() => {\n              return this._amqpChannels[`${currentTime}`].bindQueue(streamChannelQueue, streamExchange, routingKey);\n            }).then(() => {\n              return this._amqpChannels[`${currentTime}`].consume(streamChannelQueue, (message) => {\n                callback(this._parseContent(message.content), message.fields, message.properties);\n              }, merge(this._subscribeArgs, opts));\n            });\n          }\n        } else {\n          // else if current hook is channel (or a couple deviceId, channel)\n          // creates a temp queue, binds to channel exchange and starts consuming\n          const channelExchangeName = this.exchangeName(deviceId, channel);\n          const streamChannelQueue = this.tempQueue(deviceId, channel, currentTime);\n          promisesChain = this._amqpChannels[`${currentTime}`].checkExchange(channelExchangeName).then(() => {\n            return this._amqpChannels[`${currentTime}`].assertQueue(streamChannelQueue, this._streamQueueArguments);\n          }).then(() => {\n            return this._amqpChannels[`${currentTime}`].bindQueue(streamChannelQueue, channelExchangeName, routingKey);\n          }).then(() => {\n            return this._amqpChannels[`${currentTime}`].consume(streamChannelQueue, (message) => {\n              callback(this._parseContent(message.content), message.fields, message.properties);\n            }, merge(this._subscribeArgs, opts));\n          });\n        }\n        return promisesChain;\n      }).then(() => {\n        resolve(true);\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Generate the exchange name for a device's channel\n   *\n   * @private\n   * @param {String} streamName - stream name from which you want to stream\n   * @return a string that represents the stream queue\n   */\n  _cachedStreamQueue(streamName) {\n    return `${this.liveStreamByName(streamName)}.${this._liveStreamSuffix}`;\n  }\n\n}\n\n// Remove unwanted methods inherited from AmqpClient\ndelete AmqpStreamClient.onReceive;\ndelete AmqpStreamClient.publish;\ndelete AmqpStreamClient._routingKeyFor;\n\nexport default AmqpStreamClient;\n"],"sourceRoot":"./src"}