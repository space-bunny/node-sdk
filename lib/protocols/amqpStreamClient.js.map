{"version":3,"sources":["protocols/amqpStreamClient.js"],"names":[],"mappings":";;;;;;;;AAOA;;;;AACA;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;IAEM;;;;;;;;AAMJ,WANI,gBAMJ,CAAY,IAAZ,EAAkB;0BANd,kBAMc;;uEANd,6BAOI,OADU;;AAEhB,UAAK,wBAAL,GAAgC,GAAhC,CAFgB;AAGhB,UAAK,qBAAL,GAA6B,EAAE,WAAW,IAAX,EAAiB,YAAY,IAAZ,EAAkB,SAAS,KAAT,EAAlE,CAHgB;;GAAlB;;;;;;;;;;;;eANI;;+BAqBO,aAAa,MAAM;;;AAC5B,UAAM,WAAW,YAAY,GAAZ,CAAgB,UAAC,UAAD,EAAgB;AAC/C,eAAO,OAAK,iBAAL,CAAuB,UAAvB,EAAmC,IAAnC,CAAP,CAD+C;OAAhB,CAA3B,CADsB;;AAK5B,aAAO,mBAAQ,GAAR,CAAY,QAAZ,CAAP,CAL4B;;;;;;;;;;;;;;;;;;;sCAqBZ,YAAY,MAAM;;;;AAElC,aAAO,uBAAY,UAAC,OAAD,EAAU,MAAV,EAAqB;AACtC,YAAM,WAAW,WAAW,QAAX,CADqB;AAEtC,YAAM,UAAU,WAAW,OAAX,CAFsB;AAGtC,YAAM,SAAS,WAAW,MAAX,CAHuB;AAItC,YAAM,QAAQ,OAAQ,WAAW,KAAX,KAAsB,SAA7B,GAA0C,IAA3C,GAAkD,WAAW,KAAX,CAJ1B;AAKtC,YAAI,WAAW,SAAX,KAAyB,YAAY,SAAZ,IAAyB,aAAa,SAAb,CAAlD,EAA2E;AAC7E,iBAAO,yCAAP,EAD6E;SAA/E;AAGA,YAAM,aAAa,WAAW,UAAX,IAAyB,OAAK,wBAAL,CARN;AAStC,YAAM,gBAAgB,SAAhB,aAAgB,GAAY;AAAE,iBAAO,SAAP,CAAF;SAAZ,CATgB;AAUtC,YAAM,WAAW,WAAW,QAAX,IAAuB,aAAvB,CAVqB;;AAYtC,YAAM,cAAc,IAAI,IAAJ,GAAW,OAAX,EAAd,CAZgC;AAatC,eAAK,cAAL,MAAuB,WAAvB,EAAsC,IAAtC,CAA2C,UAAC,EAAD,EAAQ;AACjD,iBAAK,aAAL,MAAsB,WAAtB,IAAuC,EAAvC,CADiD;AAEjD,cAAI,gBAAgB,SAAhB;;;AAF6C,cAK7C,MAAJ,EAAY;AACV,gBAAI,KAAJ,EAAW;;;AAET,oBAAM,oBAAoB,OAAK,kBAAL,CAAwB,MAAxB,CAApB;AACN,gCAAgB,OAAK,aAAL,MAAsB,WAAtB,EACb,UADa,CACF,iBADE,EACiB,OAAK,qBAAL,CADjB,CAC6C,IAD7C,CACkD,YAAM;AACpE,yBAAO,OAAK,aAAL,MAAsB,WAAtB,EAAqC,OAArC,CAA6C,iBAA7C,EAAgE,UAAC,OAAD,EAAa;;AAElF,6BAAS,OAAK,aAAL,CAAmB,QAAQ,OAAR,CAA5B,EAA8C,QAAQ,MAAR,EAAgB,QAAQ,UAAR,CAA9D,CAFkF;mBAAb,EAGpE,qBAAM,OAAK,cAAL,EAAqB,IAA3B,CAHI,CAAP,CADoE;iBAAN,CADlE;mBAHS;aAAX,MAUO;;;AAEL,oBAAM,iBAAiB,OAAK,YAAL,CAAkB,MAAlB,EAA0B,OAAK,iBAAL,CAA3C;AACN,oBAAM,qBAAqB,OAAK,SAAL,CAAe,MAAf,EAAuB,OAAK,iBAAL,EAAwB,WAA/C,CAArB;AACN,gCAAgB,OAAK,aAAL,MAAsB,WAAtB,EAAqC,aAArC,CAAmD,cAAnD,EAAmE,IAAnE,CAAwE,YAAM;AAC5F,yBAAO,OAAK,aAAL,MAAsB,WAAtB,EAAqC,WAArC,CAAiD,kBAAjD,EAAqE,OAAK,qBAAL,CAA5E,CAD4F;iBAAN,CAAxE,CAEb,IAFa,CAER,YAAM;AACZ,yBAAO,OAAK,aAAL,MAAsB,WAAtB,EAAqC,SAArC,CAA+C,kBAA/C,EAAmE,cAAnE,EAAmF,UAAnF,CAAP,CADY;iBAAN,CAFQ,CAIb,IAJa,CAIR,YAAM;AACZ,yBAAO,OAAK,aAAL,MAAsB,WAAtB,EAAqC,OAArC,CAA6C,kBAA7C,EAAiE,UAAC,OAAD,EAAa;AACnF,6BAAS,OAAK,aAAL,CAAmB,QAAQ,OAAR,CAA5B,EAA8C,QAAQ,MAAR,EAAgB,QAAQ,UAAR,CAA9D,CADmF;mBAAb,EAErE,qBAAM,OAAK,cAAL,EAAqB,IAA3B,CAFI,CAAP,CADY;iBAAN,CAJR;mBAJK;aAVP;WADF,MAyBO;;;;AAGL,kBAAM,sBAAsB,OAAK,YAAL,CAAkB,QAAlB,EAA4B,OAA5B,CAAtB;AACN,kBAAM,qBAAqB,OAAK,SAAL,CAAe,QAAf,EAAyB,OAAzB,EAAkC,WAAlC,CAArB;AACN,8BAAgB,OAAK,aAAL,MAAsB,WAAtB,EAAqC,aAArC,CAAmD,mBAAnD,EAAwE,IAAxE,CAA6E,YAAM;AACjG,uBAAO,OAAK,aAAL,MAAsB,WAAtB,EAAqC,WAArC,CAAiD,kBAAjD,EAAqE,OAAK,qBAAL,CAA5E,CADiG;eAAN,CAA7E,CAEb,IAFa,CAER,YAAM;AACZ,uBAAO,OAAK,aAAL,MAAsB,WAAtB,EAAqC,SAArC,CAA+C,kBAA/C,EAAmE,mBAAnE,EAAwF,UAAxF,CAAP,CADY;eAAN,CAFQ,CAIb,IAJa,CAIR,YAAM;AACZ,uBAAO,OAAK,aAAL,MAAsB,WAAtB,EAAqC,OAArC,CAA6C,kBAA7C,EAAiE,UAAC,OAAD,EAAa;AACnF,2BAAS,OAAK,aAAL,CAAmB,QAAQ,OAAR,CAA5B,EAA8C,QAAQ,MAAR,EAAgB,QAAQ,UAAR,CAA9D,CADmF;iBAAb,EAErE,qBAAM,OAAK,cAAL,EAAqB,IAA3B,CAFI,CAAP,CADY;eAAN,CAJR;iBALK;WAzBP;AAwCA,iBAAO,aAAP,CA7CiD;SAAR,CAA3C,CA8CG,IA9CH,CA8CQ,YAAM;AACZ,kBAAQ,IAAR,EADY;SAAN,CA9CR,CAgDG,KAhDH,CAgDS,UAAC,MAAD,EAAY;AACnB,iBAAO,MAAP,EADmB;SAAZ,CAhDT,CAbsC;OAArB,CAAnB,CAFkC;;;;;;;;;;;;;uCA4EjB,YAAY;AAC7B,aAAU,KAAK,gBAAL,CAAsB,UAAtB,UAAqC,KAAK,iBAAL,CADlB;;;;SAtH3B;;;;;;AA6HN,OAAO,iBAAiB,SAAjB;AACP,OAAO,iBAAiB,OAAjB;AACP,OAAO,iBAAiB,cAAjB;;kBAEQ","file":"protocols/amqpStreamClient.js","sourcesContent":["/**\n * A module that exports an AmqpStreamClient client\n * which inherits from the Amqp base client\n * @module AmqpStreamClient\n */\n\n// Import some helpers modules\nimport merge from 'merge';\nimport Promise from 'bluebird';\n\n// Import AmqpClient module from which AmqpStreamClient inherits\nimport AmqpClient from './amqpClient';\n\nclass AmqpStreamClient extends AmqpClient {\n\n  /**\n   * @constructor\n   * @param {Object} opts - options must contain client and secret for access keys\n   */\n  constructor(opts) {\n    super(opts);\n    this._defaultStreamRoutingKey = '#';\n    this._streamQueueArguments = { exclusive: true, autoDelete: true, durable: false };\n  }\n\n\n  /**\n   * Subscribe to multiple stream hooks\n   *\n   * @param {Array} streamHooks - Array of objects. Each objects containing\n   * { deviceId: {string}, channel: {string}, callback: {func} }\n   * @param {Object} options - subscription options\n   * @return promise containing the result of multiple subscriptions\n   */\n  streamFrom(streamHooks, opts) {\n    const promises = streamHooks.map((streamHook) => {\n      return this._attachStreamHook(streamHook, opts);\n    });\n\n    return Promise.any(promises);\n  }\n\n  // ------------ PRIVATE METHODS -------------------\n\n  /**\n   * Start consuming messages from a device's channel\n   * It generates an auto delete queue from which consume\n   * and binds it to the channel exchange\n   *\n   * @private\n   * @param {Object} streamHook - Object containit hook info\n   * { deviceId: {String}, channel: {String}, callback: {func}}\n   * @param {Object} opts - connection options\n   * @return a promise containing current connection\n   */\n  _attachStreamHook(streamHook, opts) {\n    // Receive messages from imput queue\n    return new Promise((resolve, reject) => {\n      const deviceId = streamHook.deviceId;\n      const channel = streamHook.channel;\n      const stream = streamHook.stream;\n      const cache = (typeof(streamHook.cache) !== 'boolean') ? true : streamHook.cache;\n      if (stream === undefined && (channel === undefined || deviceId === undefined)) {\n        reject('Missing Stream or Device ID and Channel');\n      }\n      const routingKey = streamHook.routingKey || this._defaultStreamRoutingKey;\n      const emptyFunction = function () { return undefined; };\n      const callback = streamHook.callback || emptyFunction;\n\n      const currentTime = new Date().getTime();\n      this._createChannel(`${currentTime}`).then((ch) => {\n        this._amqpChannels[`${currentTime}`] = ch;\n        let promisesChain = undefined;\n        // if current hook is a stream\n        // checks the existence of the stream queue and starts consuming\n        if (stream) {\n          if (cache) {\n            // Cached streams are connected to the existing live stream queue\n            const cachedStreamQueue = this._cachedStreamQueue(stream);\n            promisesChain = this._amqpChannels[`${currentTime}`]\n              .checkQueue(cachedStreamQueue, this._streamQueueArguments).then(() => {\n                return this._amqpChannels[`${currentTime}`].consume(cachedStreamQueue, (message) => {\n                  // Call message callback\n                  callback(this._parseContent(message.content), message.fields, message.properties);\n                }, merge(this._subscribeArgs, opts));\n              });\n          } else {\n            // Uncached streams are connected to the stream exchange and create a temp queue\n            const streamExchange = this.exchangeName(stream, this._liveStreamSuffix);\n            const streamChannelQueue = this.tempQueue(stream, this._liveStreamSuffix, currentTime);\n            promisesChain = this._amqpChannels[`${currentTime}`].checkExchange(streamExchange).then(() => {\n              return this._amqpChannels[`${currentTime}`].assertQueue(streamChannelQueue, this._streamQueueArguments);\n            }).then(() => {\n              return this._amqpChannels[`${currentTime}`].bindQueue(streamChannelQueue, streamExchange, routingKey);\n            }).then(() => {\n              return this._amqpChannels[`${currentTime}`].consume(streamChannelQueue, (message) => {\n                callback(this._parseContent(message.content), message.fields, message.properties);\n              }, merge(this._subscribeArgs, opts));\n            });\n          }\n        } else {\n          // else if current hook is channel (or a couple deviceId, channel)\n          // creates a temp queue, binds to channel exchange and starts consuming\n          const channelExchangeName = this.exchangeName(deviceId, channel);\n          const streamChannelQueue = this.tempQueue(deviceId, channel, currentTime);\n          promisesChain = this._amqpChannels[`${currentTime}`].checkExchange(channelExchangeName).then(() => {\n            return this._amqpChannels[`${currentTime}`].assertQueue(streamChannelQueue, this._streamQueueArguments);\n          }).then(() => {\n            return this._amqpChannels[`${currentTime}`].bindQueue(streamChannelQueue, channelExchangeName, routingKey);\n          }).then(() => {\n            return this._amqpChannels[`${currentTime}`].consume(streamChannelQueue, (message) => {\n              callback(this._parseContent(message.content), message.fields, message.properties);\n            }, merge(this._subscribeArgs, opts));\n          });\n        }\n        return promisesChain;\n      }).then(() => {\n        resolve(true);\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Generate the exchange name for a device's channel\n   *\n   * @private\n   * @param {String} streamName - stream name from which you want to stream\n   * @return a string that represents the stream queue\n   */\n  _cachedStreamQueue(streamName) {\n    return `${this.liveStreamByName(streamName)}.${this._liveStreamSuffix}`;\n  }\n\n}\n\n// Remove unwanted methods inherited from AmqpClient\ndelete AmqpStreamClient.onReceive;\ndelete AmqpStreamClient.publish;\ndelete AmqpStreamClient._routingKeyFor;\n\nexport default AmqpStreamClient;\n"],"sourceRoot":"/Users/gfoiani/Dev/work/spacebunny/sdk/node/src"}