{"version":3,"sources":["protocols/amqpStreamClient.js"],"names":["require","CONFIG","AmqpStreamClient","opts","amqpStreamOptions","amqp","stream","_defaultStreamRoutingKey","defaultStreamRoutingKey","_streamQueueArguments","streamQueueArguments","_subscriptions","streamHooks","length","Promise","mapSeries","streamHook","_attachStreamHook","reject","Error","resolve","undefined","deviceId","channel","topic","routingKey","cache","emptyFunction","callback","currentTime","Date","getTime","tempQueue","_createChannel","then","ch","_amqpChannels","promisesChain","localOpts","_subscribeArgs","liveStreamExists","console","error","_cachedStreamQueue","checkQueue","consume","message","_parseContent","content","fields","properties","streamExchange","exchangeName","_liveStreamSuffix","checkExchange","assertQueue","bindQueue","channelExchangeName","_streamRoutingKeyFor","subscriptionId","amqpChannel","id","catch","reason","isConnected","subscription","close","streamName","params","streamRoutingKey","AmqpClient","onReceive","publish","_routingKeyFor"],"mappings":";;;;;;;;;;;;;;;;;;;;AAQA;;;;AACA;;;;AAGA;;;;;;;;;;+eAZA;;;;;;AAMA;;;AAKA;;;eAGmBA,QAAQ,wBAAR,C;IAAXC,M,YAAAA,M;;IAEFC,gB;;;AACJ;;;;AAIA,8BAAuB;AAAA,QAAXC,IAAW,uEAAJ,EAAI;;AAAA;;AAAA,oIACfA,IADe;;AAErB,QAAMC,oBAAoBH,OAAOI,IAAP,CAAYC,MAAtC;AACA,UAAKC,wBAAL,GAAgCH,kBAAkBI,uBAAlD;AACA,UAAKC,qBAAL,GAA6BL,kBAAkBM,oBAA/C;AACA,UAAKC,cAAL,GAAsB,EAAtB;AALqB;AAMtB;;AAED;;;;;;;;;;;;iCAQwC;AAAA;;AAAA,UAA7BC,WAA6B,uEAAf,EAAe;AAAA,UAAXT,IAAW,uEAAJ,EAAI;;AACtC,UAAIS,YAAYC,MAAZ,GAAqB,CAAzB,EAA4B;AAC1B,eAAOC,mBAAQC,SAAR,CAAkBH,WAAlB,EAA+B,UAACI,UAAD,EAAgB;AACpD,iBAAO,OAAKC,iBAAL,CAAuBD,UAAvB,EAAmCb,IAAnC,CAAP;AACD,SAFM,CAAP;AAGD,OAJD,MAIO;AACL,eAAOW,mBAAQI,MAAR,CAAe,IAAIC,KAAJ,CAAU,sBAAV,CAAf,CAAP;AACD;AACF;;AAED;;AAEA;;;;;;;;;;;;;;;;sCAakBH,U,EAAuB;AAAA;;AAAA,UAAXb,IAAW,uEAAJ,EAAI;;AACvC;AACA,aAAO,IAAIW,kBAAJ,CAAY,UAACM,OAAD,EAAUF,MAAV,EAAqB;AAAA,iCAIlCF,UAJkC,CAEpCV,MAFoC;AAAA,YAEpCA,MAFoC,sCAE3Be,SAF2B;AAAA,mCAIlCL,UAJkC,CAEhBM,QAFgB;AAAA,YAEhBA,QAFgB,wCAELD,SAFK;AAAA,kCAIlCL,UAJkC,CAEMO,OAFN;AAAA,YAEMA,OAFN,uCAEgBF,SAFhB;AAAA,gCAIlCL,UAJkC,CAGpCQ,KAHoC;AAAA,YAGpCA,KAHoC,qCAG5BH,SAH4B;AAAA,oCAIlCL,UAJkC,CAGjBS,UAHiB;AAAA,YAGjBA,UAHiB,yCAGJJ,SAHI;;AAKtC,YAAMK,QAAS,OAAQV,WAAWU,KAAnB,KAA8B,SAA/B,GAA4C,IAA5C,GAAmDV,WAAWU,KAA5E;AACA,YAAIpB,WAAWe,SAAX,KAAyBE,YAAYF,SAAZ,IAAyBC,aAAaD,SAA/D,CAAJ,EAA+E;AAC7EH,iBAAO,IAAIC,KAAJ,CAAU,yCAAV,CAAP;AACD;AACD,YAAMQ,gBAAgB,SAAhBA,aAAgB,GAAY;AAAE,iBAAON,SAAP;AAAmB,SAAvD;AACA,YAAMO,WAAWZ,WAAWY,QAAX,IAAuBD,aAAxC;;AAEA,YAAME,cAAc,IAAIC,IAAJ,GAAWC,OAAX,EAApB;AACA,YAAIC,kBAAJ;AACA,eAAKC,cAAL,MAAuBJ,WAAvB,EAAsCK,IAAtC,CAA2C,UAACC,EAAD,EAAQ;AACjD,iBAAKC,aAAL,MAAsBP,WAAtB,IAAuCM,EAAvC;AACA,cAAIE,sBAAJ;AACA;AACA;AACA,cAAIC,YAAY,yBAAYnC,IAAZ,CAAhB;AACAmC,sBAAY,qBAAQ,OAAKC,cAAb,EAA6BD,SAA7B,CAAZ;AACA,cAAIhC,MAAJ,EAAY;AACV,gBAAI,CAAC,OAAKkC,gBAAL,CAAsBlC,MAAtB,CAAL,EAAoC;AAClCmC,sBAAQC,KAAR,aAAwBpC,MAAxB,sBADkC,CACgB;AAClDc,sBAAQ,KAAR;AACD;AACD,gBAAIM,KAAJ,EAAW;AACT;AACAM,0BAAY,OAAKW,kBAAL,CAAwBrC,MAAxB,CAAZ;AACA+B,8BAAgB,OAAKD,aAAL,MAAsBP,WAAtB,EACbe,UADa,CACFZ,SADE,EACS,OAAKvB,qBADd,EACqCyB,IADrC,CAC0C,YAAM;AAC5D,uBAAO,OAAKE,aAAL,MAAsBP,WAAtB,EAAqCgB,OAArC,CAA6Cb,SAA7C,EAAwD,UAACc,OAAD,EAAa;AAC1E;AACAlB,2BAAS,OAAKmB,aAAL,CAAmBD,QAAQE,OAA3B,CAAT,EAA8CF,QAAQG,MAAtD,EAA8DH,QAAQI,UAAtE;AACD,iBAHM,EAGJZ,SAHI,CAAP;AAID,eANa,CAAhB;AAOD,aAVD,MAUO;AACL;AACA,kBAAMa,iBAAiB,OAAKC,YAAL,CAAkB9C,MAAlB,EAA0B,OAAK+C,iBAA/B,CAAvB;AACArB,0BAAY,OAAKA,SAAL,CAAe1B,MAAf,EAAuB,OAAK+C,iBAA5B,EAA+CxB,WAA/C,CAAZ;AACAQ,8BAAgB,OAAKD,aAAL,MAAsBP,WAAtB,EAAqCyB,aAArC,CAAmDH,cAAnD,EAAmEjB,IAAnE,CAAwE,YAAM;AAC5F,uBAAO,OAAKE,aAAL,MAAsBP,WAAtB,EAAqC0B,WAArC,CAAiDvB,SAAjD,EAA4D,OAAKvB,qBAAjE,CAAP;AACD,eAFe,EAEbyB,IAFa,CAER,YAAM;AACZ,uBAAO,OAAKE,aAAL,MAAsBP,WAAtB,EAAqC2B,SAArC,CAA+CxB,SAA/C,EAA0DmB,cAA1D,EAA0E1B,UAA1E,CAAP;AACD,eAJe,EAIbS,IAJa,CAIR,YAAM;AACZ,uBAAO,OAAKE,aAAL,MAAsBP,WAAtB,EAAqCgB,OAArC,CAA6Cb,SAA7C,EAAwD,UAACc,OAAD,EAAa;AAC1ElB,2BAAS,OAAKmB,aAAL,CAAmBD,QAAQE,OAA3B,CAAT,EAA8CF,QAAQG,MAAtD,EAA8DH,QAAQI,UAAtE;AACD,iBAFM,EAEJZ,SAFI,CAAP;AAGD,eARe,CAAhB;AASD;AACF,WA7BD,MA6BO;AACL;AACA;AACA,gBAAMmB,sBAAsB,OAAKL,YAAL,CAAkB9B,QAAlB,EAA4BC,OAA5B,CAA5B;AACAS,wBAAY,OAAKA,SAAL,CAAeV,QAAf,EAAyBC,OAAzB,EAAkCM,WAAlC,CAAZ;AACAQ,4BAAgB,OAAKD,aAAL,MAAsBP,WAAtB,EAAqCyB,aAArC,CAAmDG,mBAAnD,EAAwEvB,IAAxE,CAA6E,YAAM;AACjG,qBAAO,OAAKE,aAAL,MAAsBP,WAAtB,EAAqC0B,WAArC,CAAiDvB,SAAjD,EAA4D,OAAKvB,qBAAjE,CAAP;AACD,aAFe,EAEbyB,IAFa,CAER,YAAM;AACZ,qBAAO,OAAKE,aAAL,MAAsBP,WAAtB,EAAqC2B,SAArC,CAA+CxB,SAA/C,EAA0DyB,mBAA1D,EACL,OAAKC,oBAAL,CAA0B;AACxBpC,kCADwB,EACdC,gBADc,EACLE,sBADK,EACOD;AADP,eAA1B,CADK,CAAP;AAID,aAPe,EAObU,IAPa,CAOR,YAAM;AACZ,qBAAO,OAAKE,aAAL,MAAsBP,WAAtB,EAAqCgB,OAArC,CAA6Cb,SAA7C,EAAwD,UAACc,OAAD,EAAa;AAC1ElB,yBAAS,OAAKmB,aAAL,CAAmBD,QAAQE,OAA3B,CAAT,EAA8CF,QAAQG,MAAtD,EAA8DH,QAAQI,UAAtE;AACD,eAFM,EAEJZ,SAFI,CAAP;AAGD,aAXe,CAAhB;AAYD;AACD,iBAAOD,aAAP;AACD,SAvDD,EAuDGH,IAvDH,CAuDQ,YAAM;AACZ,cAAMyB,iBAAiB,oBAAI3B,SAAJ,CAAvB;AACA,iBAAKrB,cAAL,CAAoBgD,cAApB,IAAsC,EAAEC,aAAa/B,WAAf,EAAtC;AACAT,kBAAQ,qBAAQJ,UAAR,EAAoB,EAAE6C,IAAIF,cAAN,EAApB,CAAR;AACD,SA3DD,EA2DGG,KA3DH,CA2DS,UAACC,MAAD,EAAY;AACnB7C,iBAAO6C,MAAP;AACD,SA7DD;AA8DD,OA5EM,CAAP;AA6ED;;AAED;;;;;;;;;kCAMwC;AAAA;;AAAA,UAA5BJ,cAA4B,uEAAXtC,SAAW;;AACtC,aAAO,IAAIP,kBAAJ,CAAY,UAACM,OAAD,EAAUF,MAAV,EAAqB;AACtC,YAAI,CAAC,OAAK8C,WAAL,EAAL,EAAyB;AACvB9C,iBAAO,IAAIC,KAAJ,CAAU,oBAAV,CAAP;AACD,SAFD,MAEO;AACL,cAAM8C,eAAe,OAAKtD,cAAL,CAAoBgD,cAApB,CAArB;AACA,cAAIM,YAAJ,EAAkB;AAAA,gBACRL,WADQ,GACQK,YADR,CACRL,WADQ;;AAEhB,gBAAI,OAAKxB,aAAL,CAAmBwB,WAAnB,CAAJ,EAAqC;AACnC,qBAAKxB,aAAL,CAAmBwB,WAAnB,EAAgCM,KAAhC;AACA,qBAAO,OAAK9B,aAAL,CAAmBwB,WAAnB,CAAP;AACA,qBAAO,OAAKjD,cAAL,CAAoBgD,cAApB,CAAP;AACD;AACDvC,oBAAQ,IAAR;AACD,WARD,MAQO;AACLF,mBAAO,IAAIC,KAAJ,CAAU,wBAAV,CAAP;AACD;AACF;AACF,OAjBM,CAAP;AAkBD;;AAED;;;;;;;;;;uCAOmBgD,U,EAAY;AAC7B,aAAUA,UAAV,SAAwB,KAAKd,iBAA7B;AACD;;AAED;;;;;;;;;;2CAOkC;AAAA,UAAbe,MAAa,uEAAJ,EAAI;AAAA,6BAG5BA,MAH4B,CAE9B9C,QAF8B;AAAA,UAE9BA,QAF8B,oCAEnBD,SAFmB;AAAA,4BAG5B+C,MAH4B,CAER7C,OAFQ;AAAA,UAERA,OAFQ,mCAEEF,SAFF;AAAA,+BAG5B+C,MAH4B,CAEa3C,UAFb;AAAA,UAEaA,UAFb,sCAE0BJ,SAF1B;AAAA,0BAG5B+C,MAH4B,CAEqC5C,KAFrC;AAAA,UAEqCA,KAFrC,iCAE6CH,SAF7C;;AAIhC,UAAI,uBAAUI,UAAV,KAAyB,uBAAUH,QAAV,CAA7B,EAAkD;AAChD;AACA,eAAO,KAAKf,wBAAZ;AACD,OAHD,MAGO,IAAIkB,UAAJ,EAAgB;AACrB;AACA,eAAOA,UAAP;AACD,OAHM,MAGA;AACL,YAAI4C,mBAAmB/C,QAAvB;AACA,YAAIC,OAAJ,EAAa;AAAE8C,oCAAwB9C,OAAxB;AAAoC;AACnD,YAAIC,KAAJ,EAAW;AAAE6C,oCAAwB7C,KAAxB;AAAkC;AAC/C,oBAAU6C,gBAAV;AACD;AACF;;;;EA5L4BC,oB;;AA+L/B;;;AACA,OAAOpE,iBAAiBqE,SAAxB;AACA,OAAOrE,iBAAiBsE,OAAxB;AACA,OAAOtE,iBAAiBuE,cAAxB;;kBAEevE,gB","file":"amqpStreamClient.js","sourcesContent":["/**\n * A module that exports an AmqpStreamClient client\n * which inherits from the Amqp base client\n * @module AmqpStreamClient\n */\n\n// Import some helpers modules\nimport _ from 'lodash';\nimport Promise from 'bluebird';\nimport md5 from 'js-md5';\n\n// Import AmqpClient module from which AmqpStreamClient inherits\nimport AmqpClient from './amqpClient';\n\nconst { CONFIG } = require('../../config/constants');\n\nclass AmqpStreamClient extends AmqpClient {\n  /**\n   * @constructor\n   * @param {Object} opts - options must contain client and secret for access keys\n   */\n  constructor(opts = {}) {\n    super(opts);\n    const amqpStreamOptions = CONFIG.amqp.stream;\n    this._defaultStreamRoutingKey = amqpStreamOptions.defaultStreamRoutingKey;\n    this._streamQueueArguments = amqpStreamOptions.streamQueueArguments;\n    this._subscriptions = [];\n  }\n\n  /**\n   * Subscribe to multiple stream hooks\n   *\n   * @param {Array} streamHooks - Array of objects. Each objects containing\n   * { deviceId: {string}, channel: {string}, callback: {func} }\n   * @param {Object} options - subscription options\n   * @return promise containing the result of multiple subscriptions\n   */\n  streamFrom(streamHooks = [], opts = {}) {\n    if (streamHooks.length > 0) {\n      return Promise.mapSeries(streamHooks, (streamHook) => {\n        return this._attachStreamHook(streamHook, opts);\n      });\n    } else {\n      return Promise.reject(new Error('Missing stream hooks'));\n    }\n  }\n\n  // ------------ PRIVATE METHODS -------------------\n\n  /**\n   * Start consuming messages from a device's channel\n   * It generates an auto delete queue from which consume\n   * and binds it to the channel exchange\n   *\n   * @private\n   * @param {Object} streamHook - Object containit hook info\n   * { stream: {String}, callback: {func}}\n   * or\n   * { deviceId: {String}, channel: {String}, callback: {func}}\n   * @param {Object} opts - connection options\n   * @return a promise containing current connection\n   */\n  _attachStreamHook(streamHook, opts = {}) {\n    // Receive messages from imput queue\n    return new Promise((resolve, reject) => {\n      const {\n        stream = undefined, deviceId = undefined, channel = undefined,\n        topic = undefined, routingKey = undefined\n      } = streamHook;\n      const cache = (typeof (streamHook.cache) !== 'boolean') ? true : streamHook.cache;\n      if (stream === undefined && (channel === undefined || deviceId === undefined)) {\n        reject(new Error('Missing Stream or Device ID and Channel'));\n      }\n      const emptyFunction = function () { return undefined; };\n      const callback = streamHook.callback || emptyFunction;\n\n      const currentTime = new Date().getTime();\n      let tempQueue;\n      this._createChannel(`${currentTime}`).then((ch) => {\n        this._amqpChannels[`${currentTime}`] = ch;\n        let promisesChain;\n        // if current hook is a stream\n        // checks the existence of the stream queue and starts consuming\n        let localOpts = _.cloneDeep(opts);\n        localOpts = _.merge(this._subscribeArgs, localOpts);\n        if (stream) {\n          if (!this.liveStreamExists(stream)) {\n            console.error(`Stream ${stream} does not exist`); // eslint-disable-line no-console\n            resolve(false);\n          }\n          if (cache) {\n            // Cached streams are connected to the existing live stream queue\n            tempQueue = this._cachedStreamQueue(stream);\n            promisesChain = this._amqpChannels[`${currentTime}`]\n              .checkQueue(tempQueue, this._streamQueueArguments).then(() => {\n                return this._amqpChannels[`${currentTime}`].consume(tempQueue, (message) => {\n                  // Call message callback\n                  callback(this._parseContent(message.content), message.fields, message.properties);\n                }, localOpts);\n              });\n          } else {\n            // Uncached streams are connected to the stream exchange and create a temp queue\n            const streamExchange = this.exchangeName(stream, this._liveStreamSuffix);\n            tempQueue = this.tempQueue(stream, this._liveStreamSuffix, currentTime);\n            promisesChain = this._amqpChannels[`${currentTime}`].checkExchange(streamExchange).then(() => {\n              return this._amqpChannels[`${currentTime}`].assertQueue(tempQueue, this._streamQueueArguments);\n            }).then(() => {\n              return this._amqpChannels[`${currentTime}`].bindQueue(tempQueue, streamExchange, routingKey);\n            }).then(() => {\n              return this._amqpChannels[`${currentTime}`].consume(tempQueue, (message) => {\n                callback(this._parseContent(message.content), message.fields, message.properties);\n              }, localOpts);\n            });\n          }\n        } else {\n          // else if current hook is channel (or a couple deviceId, channel)\n          // creates a temp queue, binds to channel exchange and starts consuming\n          const channelExchangeName = this.exchangeName(deviceId, channel);\n          tempQueue = this.tempQueue(deviceId, channel, currentTime);\n          promisesChain = this._amqpChannels[`${currentTime}`].checkExchange(channelExchangeName).then(() => {\n            return this._amqpChannels[`${currentTime}`].assertQueue(tempQueue, this._streamQueueArguments);\n          }).then(() => {\n            return this._amqpChannels[`${currentTime}`].bindQueue(tempQueue, channelExchangeName,\n              this._streamRoutingKeyFor({\n                deviceId, channel, routingKey, topic\n              }));\n          }).then(() => {\n            return this._amqpChannels[`${currentTime}`].consume(tempQueue, (message) => {\n              callback(this._parseContent(message.content), message.fields, message.properties);\n            }, localOpts);\n          });\n        }\n        return promisesChain;\n      }).then(() => {\n        const subscriptionId = md5(tempQueue);\n        this._subscriptions[subscriptionId] = { amqpChannel: currentTime };\n        resolve(_.merge(streamHook, { id: subscriptionId }));\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Unsubscribe client from a topic\n   *\n   * @param {String} subscriptionId - subscription ID\n   * @return a promise containing the result of the operation\n   */\n  unsubscribe(subscriptionId = undefined) {\n    return new Promise((resolve, reject) => {\n      if (!this.isConnected()) {\n        reject(new Error('Invalid connection'));\n      } else {\n        const subscription = this._subscriptions[subscriptionId];\n        if (subscription) {\n          const { amqpChannel } = subscription;\n          if (this._amqpChannels[amqpChannel]) {\n            this._amqpChannels[amqpChannel].close();\n            delete this._amqpChannels[amqpChannel];\n            delete this._subscriptions[subscriptionId];\n          }\n          resolve(true);\n        } else {\n          reject(new Error('Subscription not found'));\n        }\n      }\n    });\n  }\n\n  /**\n   * Generate the exchange name for a device's channel\n   *\n   * @private\n   * @param {String} streamName - stream name from which you want to stream\n   * @return a string that represents the stream queue\n   */\n  _cachedStreamQueue(streamName) {\n    return `${streamName}.${this._liveStreamSuffix}`;\n  }\n\n  /**\n   * Generate the exchange name for a device's channel\n   *\n   * @private\n   * @param {Object} params - params\n   * @return a string that represents the rounting key\n   */\n  _streamRoutingKeyFor(params = {}) {\n    const {\n      deviceId = undefined, channel = undefined, routingKey = undefined, topic = undefined\n    } = params;\n    if (_.isEmpty(routingKey) && _.isEmpty(deviceId)) {\n      // if both routingKey and deviceId are empty return default routingKey\n      return this._defaultStreamRoutingKey;\n    } else if (routingKey) {\n      // return routing key if present\n      return routingKey;\n    } else {\n      let streamRoutingKey = deviceId;\n      if (channel) { streamRoutingKey += `.${channel}`; }\n      if (topic) { streamRoutingKey += `.${topic}`; }\n      return `${streamRoutingKey}`;\n    }\n  }\n}\n\n// Remove unwanted methods inherited from AmqpClient\ndelete AmqpStreamClient.onReceive;\ndelete AmqpStreamClient.publish;\ndelete AmqpStreamClient._routingKeyFor;\n\nexport default AmqpStreamClient;\n"],"sourceRoot":"../src"}