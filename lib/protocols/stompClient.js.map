{"version":3,"sources":["protocols/stompClient.js"],"names":["CONFIG","require","StompClient","opts","_stompConnection","undefined","_subscription","process","_protocol","stompOpts","stomp","webStompOpts","webStomp","_webSocketOpts","webSocket","_connectionHeaders","connection","headers","_connectionOpts","_existingQueuePrefix","existingQueuePrefix","callback","resolve","reject","connect","then","client","topic","_subcriptionFor","_inboxTopic","subscriptionCallback","message","stompMessage","_deviceId","ackNeeded","_autoAck","ack","blackListed","nack","_parseContent","body","subscribe","catch","reason","channel","destination","_destinationFor","send","_encapsulateContent","unsubscribe","disconnect","getEndpointConfigs","endpointConfigs","connectionParams","_tls","overTCP","host","protocols","tlsPort","_tlsOpts","port","protocol","tls","connectionString","endpoint","ws","WebSocket","over","heartbeat","outgoing","incoming","debug","login","deviceId","passcode","secret","vhost","err","type","ackTypes","console","error"],"mappings":"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","file":"stompClient.js","sourcesContent":["/**\n * A module that exports an StompClient client\n * which inherits from the SpaceBunny base client\n * @module StompClient\n */\n\n// Import some helpers modules\nimport merge from 'merge';\nimport Promise from 'bluebird';\nimport _ from 'lodash';\n\n// Import stomp library\nimport Stomp from 'stompjs';\n\n// Import SpaceBunny main module from which StompClient inherits\nimport SpaceBunny from '../spacebunny';\nimport StompMessage from '../messages/stompMessage';\nconst CONFIG = require('../../config/constants').CONFIG;\n\nclass StompClient extends SpaceBunny {\n\n  /**\n   * @constructor\n   * @param {Object} opts - options must contain Device-Key or connection options\n   * (deviceId and secret) for devices.\n   */\n  constructor(opts) {\n    super(opts);\n    this._stompConnection = undefined;\n    this._subscription = undefined;\n    if (typeof process === 'object' && `${process}` === '[object process]') {\n      this._protocol = 'stomp';\n    } else {\n      this._protocol = 'webStomp';\n    }\n    const stompOpts = CONFIG.stomp;\n    const webStompOpts = CONFIG.webStomp;\n    this._webSocketOpts = webStompOpts.webSocket;\n    this._connectionHeaders = stompOpts.connection.headers;\n    this._connectionOpts = stompOpts.connection.opts;\n    this._existingQueuePrefix = stompOpts.existingQueuePrefix;\n  }\n\n  /**\n   * Subscribe to input channel\n   *\n   * @param {function} callback - function called every time a message is received\n   * passing the current message as argument\n   * @param {Object} options - subscription options\n   * @return promise containing the result of the subscription\n   */\n  onReceive(callback, opts) {\n    opts = merge({}, opts);\n    // subscribe for input messages\n    return new Promise((resolve, reject) => {\n      this.connect().then((client) => {\n        const topic = this._subcriptionFor(this._existingQueuePrefix, this._inboxTopic);\n        const subscriptionCallback = (message) => {\n          // Create message object\n          const stompMessage = new StompMessage(message, this._deviceId, opts);\n          const ackNeeded = this._autoAck(opts.ack);\n          // Check if should be accepted or not\n          if (stompMessage.blackListed()) {\n            if (ackNeeded) { message.nack(); }\n            return;\n          }\n          // Call message callback\n          callback(this._parseContent(stompMessage.body), stompMessage.headers);\n          // Check if ACK is needed\n          if (ackNeeded) { message.ack(); }\n        };\n        this._subscription = client.subscribe(topic, subscriptionCallback);\n        resolve(true);\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Publish a message on a specific channel\n   *\n   * @param {String} channel - channel name on which you want to publish a message\n   * @param {Object} message - the message payload\n   * @param {Object} opts - publication options\n   * @return a promise containing the result of the operation\n   */\n  publish(channel, message, opts) {\n    opts = merge({}, opts);\n    // Publish message\n    return new Promise((resolve, reject) => {\n      this.connect().then((client) => {\n        const destination = this._destinationFor('exchange', channel);\n        client.send(destination, this._connectionHeaders, this._encapsulateContent(message));\n        resolve(true);\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Destroy the connection between the stomp client and broker\n   *\n   * @return a promise containing the result of the operation\n   */\n  disconnect() {\n    return new Promise((resolve, reject) => {\n      if (this._stompConnection === undefined) {\n        reject('Invalid connection');\n      } else {\n        if (this._subscription !== undefined) {\n          this._subscription.unsubscribe();\n        }\n        this._stompConnection.disconnect(() => {\n          this._stompConnection = undefined;\n          resolve(true);\n        }).catch((reason) => {\n          reject(reason);\n        });\n      }\n    });\n  }\n\n  /**\n   * Establish an stomp connection with the broker.\n   * If a connection already exists, returns the current connection\n   *\n   * @param {Object} opts - connection options\n   * @return a promise containing current connection\n   */\n  connect(opts = {}) {\n    opts = merge(this._connectionOpts, opts);\n    return new Promise((resolve, reject) => {\n      this.getEndpointConfigs().then((endpointConfigs) => {\n        const connectionParams = endpointConfigs.connection;\n        if (this._stompConnection !== undefined) {\n          resolve(this._stompConnection);\n        } else {\n          try {\n            let client = undefined;\n            if (typeof process === 'object' && `${process}` === '[object process]') {\n              // code is runnning in nodejs: STOMP uses TCP sockets\n              if (this._tls) {\n                client = Stomp.overTCP(connectionParams.host, connectionParams.protocols.stomp.tlsPort, this._tlsOpts);\n              } else {\n                client = Stomp.overTCP(connectionParams.host, connectionParams.protocols.stomp.port);\n              }\n            } else {\n              // code is runnning in a browser: web STOMP uses Web sockets\n              const protocol = (this._tls) ? this._webSocketOpts.tls.protocol : this._webSocketOpts.protocol;\n              const port = (this._tls) ? connectionParams.protocols.webStomp.tlsPort :\n                connectionParams.protocols.webStomp.port;\n              const connectionString = `${protocol}://${connectionParams.host}:${port}/${this._webSocketOpts.endpoint}`;\n              const ws = new WebSocket(connectionString);\n              client = Stomp.over(ws);\n              client.heartbeat.outgoing = 10000;\n              client.heartbeat.incoming = 10000;\n              client.debug = null;\n            }\n            const headers = merge(this._connectionHeaders, {\n              login: connectionParams.deviceId || connectionParams.client,\n              passcode: connectionParams.secret,\n              host: connectionParams.vhost\n            });\n            client.connect(headers, () => {\n              this._stompConnection = client;\n              resolve(this._stompConnection);\n            }, (err) => {\n              reject(err);\n            });\n          } catch (reason) {\n            reject(reason);\n          }\n        }\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  // ------------ PRIVATE METHODS -------------------\n\n  /**\n   * Generate the subscription string for a specific channel\n   *\n   * @private\n   * @param {String} type - resource type on which subscribe or publish [exchange/queue]\n   * @param {String} channel - channel name on which you want to publish a message\n   * @return a string that represents the topic name for that channel\n   */\n  _subcriptionFor(type, channel) {\n    return `/${type}/${this.deviceId()}.${channel}`;\n  }\n\n  /**\n   * Generate the destination string for a specific channel\n   *\n   * @private\n   * @param {String} type - resource type on which subscribe or publish [exchange/queue]\n   * @param {String} channel - channel name on which you want to publish a message\n   * @return a string that represents the topic name for that channel\n   */\n  _destinationFor(type, channel) {\n    return `/${type}/${this.deviceId()}/${this.deviceId()}.${channel}`;\n  }\n\n  /**\n   * Check if the SDK have to automatically ack messages\n   * By default STOMP messages are acked by the server\n   * they need to be acked if client subscribes with { ack: 'client' } option\n   *\n   * @private\n   * @param {String} ack - the ack type, it should be 'client' or null\n   * @return boolean - true if messages have to be autoacked, false otherwise\n   */\n  _autoAck(ack) {\n    if (ack) {\n      if (!_.includes(CONFIG[this._protocol].ackTypes, ack)) {\n        console.error('Wrong acknowledge type'); // eslint-disable-line no-console\n      }\n      switch (ack) {\n        case 'client':\n          return false;\n        default:\n          return true;\n      }\n    }\n    return false;\n  }\n\n}\n\nexport default StompClient;\n"],"sourceRoot":"/Users/michele/Develop/projects/SpaceBunny/sdk/node-sdk/src"}