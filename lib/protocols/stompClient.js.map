{"version":3,"sources":["protocols/stompClient.js"],"names":[],"mappings":"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","file":"protocols/stompClient.js","sourcesContent":["/**\n * A module that exports an StompClient client\n * which inherits from the SpaceBunny base client\n * @module StompClient\n */\n\n// Import some helpers modules\nimport merge from 'merge';\nimport Promise from 'bluebird';\nimport _ from 'lodash';\n\n// Import stomp library\nimport Stomp from 'stompjs';\n\n// Import SpaceBunny main module from which StompClient inherits\nimport SpaceBunny from '../spacebunny';\nimport StompMessage from '../messages/stompMessage';\nconst CONFIG = require('../../config/constants').CONFIG;\n\nclass StompClient extends SpaceBunny {\n\n  /**\n   * @constructor\n   * @param {Object} opts - options must contain Device-Key or connection options\n   * (deviceId and secret) for devices.\n   */\n  constructor(opts) {\n    super(opts);\n    this._stompConnection = undefined;\n    this._subscription = undefined;\n    if (typeof process === 'object' && `${process}` === '[object process]') {\n      this._protocol = 'stomp';\n    } else {\n      this._protocol = 'webStomp';\n    }\n    const stompOpts = CONFIG.stomp;\n    const webStompOpts = CONFIG.webStomp;\n    this._webSocketOpts = webStompOpts.webSocket;\n    this._connectionHeaders = stompOpts.connection.headers;\n    this._connectionOpts = stompOpts.connection.opts;\n    this._existingQueuePrefix = stompOpts.existingQueuePrefix;\n  }\n\n  /**\n   * Subscribe to input channel\n   *\n   * @param {function} callback - function called every time a message is received\n   * passing the current message as argument\n   * @param {Object} options - subscription options\n   * @return promise containing the result of the subscription\n   */\n  onReceive(callback, opts) {\n    opts = merge({}, opts);\n    // subscribe for input messages\n    return new Promise((resolve, reject) => {\n      this.connect().then((client) => {\n        const topic = this._subcriptionFor(this._existingQueuePrefix, this._inboxTopic);\n        const subscriptionCallback = (message) => {\n          // Create message object\n          const stompMessage = new StompMessage(message, this._deviceId, opts);\n          const ackNeeded = this._autoAck(opts.ack);\n          // Check if should be accepted or not\n          if (stompMessage.blackListed()) {\n            if (ackNeeded) { message.nack(); }\n            return;\n          }\n          // Call message callback\n          callback(this._parseContent(stompMessage.body), stompMessage.headers);\n          // Check if ACK is needed\n          if (ackNeeded) { message.ack(); }\n        };\n        this._subscription = client.subscribe(topic, subscriptionCallback);\n        resolve(true);\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Publish a message on a specific channel\n   *\n   * @param {String} channel - channel name on which you want to publish a message\n   * @param {Object} message - the message payload\n   * @param {Object} opts - publication options\n   * @return a promise containing the result of the operation\n   */\n  publish(channel, message, opts) {\n    opts = merge({}, opts);\n    // Publish message\n    return new Promise((resolve, reject) => {\n      this.connect().then((client) => {\n        const destination = this._destinationFor('exchange', channel);\n        client.send(destination, this._connectionHeaders, this._encapsulateContent(message));\n        resolve(true);\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Destroy the connection between the stomp client and broker\n   *\n   * @return a promise containing the result of the operation\n   */\n  disconnect() {\n    return new Promise((resolve, reject) => {\n      if (this._stompConnection === undefined) {\n        reject('Invalid connection');\n      } else {\n        if (this._subscription !== undefined) {\n          this._subscription.unsubscribe();\n        }\n        this._stompConnection.disconnect(() => {\n          this._stompConnection = undefined;\n          resolve(true);\n        }).catch((reason) => {\n          reject(reason);\n        });\n      }\n    });\n  }\n\n  /**\n   * Establish an stomp connection with the broker.\n   * If a connection already exists, returns the current connection\n   *\n   * @param {Object} opts - connection options\n   * @return a promise containing current connection\n   */\n  connect(opts = {}) {\n    opts = merge(this._connectionOpts, opts);\n    return new Promise((resolve, reject) => {\n      this.getEndpointConfigs().then((endpointConfigs) => {\n        const connectionParams = endpointConfigs.connection;\n        if (this._stompConnection !== undefined) {\n          resolve(this._stompConnection);\n        } else {\n          try {\n            let client = undefined;\n            if (typeof process === 'object' && `${process}` === '[object process]') {\n              // code is runnning in nodejs: STOMP uses TCP sockets\n              if (this._tls) {\n                client = Stomp.overTCP(connectionParams.host, connectionParams.protocols.stomp.tlsPort, this._tlsOpts);\n              } else {\n                client = Stomp.overTCP(connectionParams.host, connectionParams.protocols.stomp.port);\n              }\n            } else {\n              // code is runnning in a browser: web STOMP uses Web sockets\n              const protocol = (this._tls) ? this._webSocketOpts.tls.protocol : this._webSocketOpts.protocol;\n              const port = (this._tls) ? connectionParams.protocols.webStomp.tlsPort :\n                connectionParams.protocols.webStomp.port;\n              const connectionString = `${protocol}://${connectionParams.host}:${port}/${this._webSocketOpts.endpoint}`;\n              const ws = new WebSocket(connectionString);\n              client = Stomp.over(ws);\n              client.heartbeat.outgoing = 10000;\n              client.heartbeat.incoming = 10000;\n              client.debug = null;\n            }\n            const headers = merge(this._connectionHeaders, {\n              login: connectionParams.deviceId || connectionParams.client,\n              passcode: connectionParams.secret,\n              host: connectionParams.vhost\n            });\n            client.connect(headers, () => {\n              this._stompConnection = client;\n              resolve(this._stompConnection);\n            }, (err) => {\n              reject(err);\n            });\n          } catch (reason) {\n            reject(reason);\n          }\n        }\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  // ------------ PRIVATE METHODS -------------------\n\n  /**\n   * Generate the subscription string for a specific channel\n   *\n   * @private\n   * @param {String} type - resource type on which subscribe or publish [exchange/queue]\n   * @param {String} channel - channel name on which you want to publish a message\n   * @return a string that represents the topic name for that channel\n   */\n  _subcriptionFor(type, channel) {\n    return `/${type}/${this.deviceId()}.${channel}`;\n  }\n\n  /**\n   * Generate the destination string for a specific channel\n   *\n   * @private\n   * @param {String} type - resource type on which subscribe or publish [exchange/queue]\n   * @param {String} channel - channel name on which you want to publish a message\n   * @return a string that represents the topic name for that channel\n   */\n  _destinationFor(type, channel) {\n    return `/${type}/${this.deviceId()}/${this.deviceId()}.${channel}`;\n  }\n\n  /**\n   * Check if the SDK have to automatically ack messages\n   * By default STOMP messages are acked by the server\n   * they need to be acked if client subscribes with { ack: 'client' } option\n   *\n   * @private\n   * @param {String} ack - the ack type, it should be 'client' or null\n   * @return boolean - true if messages have to be autoacked, false otherwise\n   */\n  _autoAck(ack) {\n    if (ack) {\n      if (!_.includes(CONFIG[this._protocol].ackTypes, ack)) {\n        console.error('Wrong acknowledge type'); // eslint-disable-line no-console\n      }\n      switch (ack) {\n        case 'client':\n          return false;\n        default:\n          return true;\n      }\n    }\n    return false;\n  }\n\n}\n\nexport default StompClient;\n"],"sourceRoot":"/Users/gfoiani/Dev/work/spacebunny/sdk/node/src"}