{"version":3,"sources":["protocols/stompClient.js"],"names":["CONFIG","require","StompClient","opts","_stompConnection","undefined","_subscription","process","_protocol","stompOpts","stomp","webStompOpts","webStomp","_webSocketOpts","webSocket","_connectionHeaders","connection","headers","_connectionOpts","_existingQueuePrefix","existingQueuePrefix","callback","Promise","resolve","reject","connect","then","client","topic","_subcriptionFor","_inboxTopic","subscriptionCallback","message","stompMessage","StompMessage","_deviceId","ackNeeded","_autoAck","ack","blackListed","nack","_parseContent","body","subscribe","catch","reason","channel","destination","_destinationFor","send","_encapsulateContent","unsubscribe","disconnect","emit","getEndpointConfigs","endpointConfigs","connectionParams","_tls","Stomp","overTCP","host","protocols","tlsPort","_tlsOpts","port","protocol","tls","connectionString","endpoint","ws","WebSocket","over","heartbeat","outgoing","incoming","debug","login","deviceId","passcode","secret","vhost","err","type","ackTypes","console","error","SpaceBunny"],"mappings":"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","file":"stompClient.js","sourcesContent":["/**\n * A module that exports an StompClient client\n * which inherits from the SpaceBunny base client\n * @module StompClient\n */\n\n// Import some helpers modules\nimport merge from 'merge';\nimport Promise from 'bluebird';\nimport _ from 'lodash';\n\n// Import stomp library\nimport Stomp from 'stompjs';\n\n// Import SpaceBunny main module from which StompClient inherits\nimport SpaceBunny from '../spacebunny';\nimport StompMessage from '../messages/stompMessage';\nconst CONFIG = require('../../config/constants').CONFIG;\n\nclass StompClient extends SpaceBunny {\n\n  /**\n   * @constructor\n   * @param {Object} opts - options must contain Device-Key or connection options\n   * (deviceId and secret) for devices.\n   */\n  constructor(opts) {\n    super(opts);\n    this._stompConnection = undefined;\n    this._subscription = undefined;\n    if (typeof process === 'object' && `${process}` === '[object process]') {\n      this._protocol = 'stomp';\n    } else {\n      this._protocol = 'webStomp';\n    }\n    const stompOpts = CONFIG.stomp;\n    const webStompOpts = CONFIG.webStomp;\n    this._webSocketOpts = webStompOpts.webSocket;\n    this._connectionHeaders = stompOpts.connection.headers;\n    this._connectionOpts = stompOpts.connection.opts;\n    this._existingQueuePrefix = stompOpts.existingQueuePrefix;\n  }\n\n  /**\n   * Subscribe to input channel\n   *\n   * @param {function} callback - function called every time a message is received\n   * passing the current message as argument\n   * @param {Object} options - subscription options\n   * @return promise containing the result of the subscription\n   */\n  onReceive(callback, opts) {\n    opts = merge({}, opts);\n    // subscribe for input messages\n    return new Promise((resolve, reject) => {\n      this.connect().then((client) => {\n        const topic = this._subcriptionFor(this._existingQueuePrefix, this._inboxTopic);\n        const subscriptionCallback = (message) => {\n          // Create message object\n          const stompMessage = new StompMessage(message, this._deviceId, opts);\n          const ackNeeded = this._autoAck(opts.ack);\n          // Check if should be accepted or not\n          if (stompMessage.blackListed()) {\n            if (ackNeeded) { message.nack(); }\n            return;\n          }\n          // Call message callback\n          callback(this._parseContent(stompMessage.body), stompMessage.headers);\n          // Check if ACK is needed\n          if (ackNeeded) { message.ack(); }\n        };\n        this._subscription = client.subscribe(topic, subscriptionCallback);\n        resolve(true);\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Publish a message on a specific channel\n   *\n   * @param {String} channel - channel name on which you want to publish a message\n   * @param {Object} message - the message payload\n   * @param {Object} opts - publication options\n   * @return a promise containing the result of the operation\n   */\n  publish(channel, message, opts) {\n    opts = merge({}, opts);\n    // Publish message\n    return new Promise((resolve, reject) => {\n      this.connect().then((client) => {\n        const destination = this._destinationFor('exchange', channel);\n        client.send(destination, this._connectionHeaders, this._encapsulateContent(message));\n        resolve(true);\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Destroy the connection between the stomp client and broker\n   *\n   * @return a promise containing the result of the operation\n   */\n  disconnect() {\n    return new Promise((resolve, reject) => {\n      if (this._stompConnection === undefined) {\n        reject('Invalid connection');\n      } else {\n        if (this._subscription !== undefined) {\n          this._subscription.unsubscribe();\n        }\n        this._stompConnection.disconnect(() => {\n          this.emit('disconnect');\n          this._stompConnection = undefined;\n          resolve(true);\n        }).catch((reason) => {\n          this._stompConnection = undefined;\n          reject(reason);\n        });\n      }\n    });\n  }\n\n  /**\n   * Establish an stomp connection with the broker.\n   * If a connection already exists, returns the current connection\n   *\n   * @param {Object} opts - connection options\n   * @return a promise containing current connection\n   */\n  connect(opts = {}) {\n    opts = merge(this._connectionOpts, opts);\n    return new Promise((resolve, reject) => {\n      this.getEndpointConfigs().then((endpointConfigs) => {\n        const connectionParams = endpointConfigs.connection;\n        if (this._stompConnection !== undefined) {\n          resolve(this._stompConnection);\n        } else {\n          try {\n            let client = undefined;\n            if (typeof process === 'object' && `${process}` === '[object process]') {\n              // code is runnning in nodejs: STOMP uses TCP sockets\n              if (this._tls) {\n                client = Stomp.overTCP(connectionParams.host, connectionParams.protocols.stomp.tlsPort, this._tlsOpts);\n              } else {\n                client = Stomp.overTCP(connectionParams.host, connectionParams.protocols.stomp.port);\n              }\n            } else {\n              // code is runnning in a browser: web STOMP uses Web sockets\n              const protocol = (this._tls) ? this._webSocketOpts.tls.protocol : this._webSocketOpts.protocol;\n              const port = (this._tls) ? connectionParams.protocols.webStomp.tlsPort :\n                connectionParams.protocols.webStomp.port;\n              const connectionString = `${protocol}://${connectionParams.host}:${port}/${this._webSocketOpts.endpoint}`;\n              const ws = new WebSocket(connectionString);\n              client = Stomp.over(ws);\n              client.heartbeat.outgoing = 10000;\n              client.heartbeat.incoming = 10000;\n              client.debug = null;\n            }\n            const headers = merge(this._connectionHeaders, {\n              login: connectionParams.deviceId || connectionParams.client,\n              passcode: connectionParams.secret,\n              host: connectionParams.vhost\n            });\n            client.connect(headers, () => {\n              this._stompConnection = client;\n              this.emit('connect');\n              resolve(this._stompConnection);\n            }, (err) => {\n              this.emit('error', err);\n              this._stompConnection = undefined;\n              reject(err);\n            });\n          } catch (reason) {\n            reject(reason);\n          }\n        }\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  isConnected() {\n    return (this._stompConnection !== undefined);\n  }\n\n  // ------------ PRIVATE METHODS -------------------\n\n  /**\n   * Generate the subscription string for a specific channel\n   *\n   * @private\n   * @param {String} type - resource type on which subscribe or publish [exchange/queue]\n   * @param {String} channel - channel name on which you want to publish a message\n   * @return a string that represents the topic name for that channel\n   */\n  _subcriptionFor(type, channel) {\n    return `/${type}/${this.deviceId()}.${channel}`;\n  }\n\n  /**\n   * Generate the destination string for a specific channel\n   *\n   * @private\n   * @param {String} type - resource type on which subscribe or publish [exchange/queue]\n   * @param {String} channel - channel name on which you want to publish a message\n   * @return a string that represents the topic name for that channel\n   */\n  _destinationFor(type, channel) {\n    return `/${type}/${this.deviceId()}/${this.deviceId()}.${channel}`;\n  }\n\n  /**\n   * Check if the SDK have to automatically ack messages\n   * By default STOMP messages are acked by the server\n   * they need to be acked if client subscribes with { ack: 'client' } option\n   *\n   * @private\n   * @param {String} ack - the ack type, it should be 'client' or null\n   * @return boolean - true if messages have to be autoacked, false otherwise\n   */\n  _autoAck(ack) {\n    if (ack) {\n      if (!_.includes(CONFIG[this._protocol].ackTypes, ack)) {\n        console.error('Wrong acknowledge type'); // eslint-disable-line no-console\n      }\n      switch (ack) {\n        case 'client':\n          return false;\n        default:\n          return true;\n      }\n    }\n    return false;\n  }\n\n}\n\nexport default StompClient;\n"],"sourceRoot":"../src"}