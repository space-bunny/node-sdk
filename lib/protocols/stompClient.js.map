{"version":3,"sources":["protocols/stompClient.js"],"names":[],"mappings":"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","file":"protocols/stompClient.js","sourcesContent":["/**\n * A module that exports an StompClient client\n * which inherits from the SpaceBunny base client\n * @module StompClient\n */\n\n// Import some helpers modules\nimport merge from 'merge';\nimport Promise from 'bluebird';\nimport _ from 'lodash';\n\n// Import stomp library\nimport Stomp from 'stompjs';\n\n// Import SpaceBunny main module from which StompClient inherits\nimport SpaceBunny from '../spacebunny';\nimport StompMessage from '../messages/stompMessage';\nconst CONFIG = require('../../config/constants').CONFIG;\n\nclass StompClient extends SpaceBunny {\n\n  /**\n   * @constructor\n   * @param {Object} opts - options must contain Device-Key or connection options\n   * (deviceId and secret) for devices.\n   */\n  constructor(opts) {\n    super(opts);\n    this._stompConnection = undefined;\n    this._subscription = undefined;\n    if (typeof process === 'object' && `${process}` === '[object process]') {\n      this._protocol = 'stomp';\n    } else {\n      this._protocol = 'webStomp';\n    }\n    const stompOpts = CONFIG.stomp;\n    const webStompOpts = CONFIG.webStomp;\n    this._webSocketOpts = webStompOpts.webSocket;\n    this._connectionHeaders = stompOpts.connection.headers;\n    this._existingQueuePrefix = stompOpts.existingQueuePrefix;\n  }\n\n  /**\n   * Subscribe to input channel\n   *\n   * @param {function} callback - function called every time a message is received\n   * passing the current message as argument\n   * @param {Object} options - subscription options\n   * @return promise containing the result of the subscription\n   */\n  onReceive(callback, opts) {\n    opts = merge({}, opts);\n    // subscribe for input messages\n    return new Promise((resolve, reject) => {\n      this._connect().then((client) => {\n        const topic = this._subcriptionFor(this._existingQueuePrefix, this._inboxTopic);\n        const subscriptionCallback = (message) => {\n          // Create message object\n          const stompMessage = new StompMessage(message, this._deviceId, opts);\n          const ackNeeded = this._autoAck(opts.ack);\n          // Check if should be accepted or not\n          if (stompMessage.blackListed()) {\n            if (ackNeeded) { message.nack(); }\n            return;\n          }\n          // Call message callback\n          callback(this._parseContent(stompMessage.body), stompMessage.headers);\n          // Check if ACK is needed\n          if (ackNeeded) { message.ack(); }\n        };\n        this._subscription = client.subscribe(topic, subscriptionCallback);\n        resolve(true);\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Publish a message on a specific channel\n   *\n   * @param {String} channel - channel name on which you want to publish a message\n   * @param {Object} message - the message payload\n   * @param {Object} opts - publication options\n   * @return a promise containing the result of the operation\n   */\n  publish(channel, message, opts) {\n    opts = merge({}, opts);\n    // Publish message\n    return new Promise((resolve, reject) => {\n      this._connect().then((client) => {\n        const destination = this._destinationFor('exchange', channel);\n        client.send(destination, this._connectionHeaders, this._encapsulateContent(message));\n        resolve(true);\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Destroy the connection between the stomp client and broker\n   *\n   * @return a promise containing the result of the operation\n   */\n  disconnect() {\n    return new Promise((resolve, reject) => {\n      if (this._stompConnection === undefined) {\n        reject('Invalid connection');\n      } else {\n        if (this._subscription !== undefined) {\n          this._subscription.unsubscribe();\n        }\n        this._stompConnection.disconnect(() => {\n          this._stompConnection = undefined;\n          resolve(true);\n        }).catch((reason) => {\n          reject(reason);\n        });\n      }\n    });\n  }\n\n  // ------------ PRIVATE METHODS -------------------\n\n  /**\n   * Establish an stomp connection with the broker.\n   * If a connection already exists, returns the current connection\n   *\n   * @private\n   * @param {Object} opts - connection options\n   * @return a promise containing current connection\n   */\n  _connect(opts) {\n    opts = merge({}, opts);\n    return new Promise((resolve, reject) => {\n      this.getEndpointConfigs().then((endpointConfigs) => {\n        const connectionParams = endpointConfigs.connection;\n        if (this._stompConnection !== undefined) {\n          resolve(this._stompConnection);\n        } else {\n          try {\n            let client = undefined;\n            if (typeof process === 'object' && `${process}` === '[object process]') {\n              // code is runnning in nodejs: STOMP uses TCP sockets\n              if (this._ssl) {\n                client = Stomp.overTCP(connectionParams.host, connectionParams.protocols.stomp.sslPort, this._sslOpts);\n              } else {\n                client = Stomp.overTCP(connectionParams.host, connectionParams.protocols.stomp.port);\n              }\n            } else {\n              // code is runnning in a browser: web STOMP uses Web sockets\n              const protocol = (this._ssl) ? this._webSocketOpts.ssl.protocol : this._webSocketOpts.protocol;\n              const port = (this._ssl) ? connectionParams.protocols.webStomp.sslPort :\n                connectionParams.protocols.webStomp.port;\n              const connectionString = `${protocol}://${connectionParams.host}:${port}/${this._webSocketOpts.endpoint}`;\n              const ws = new WebSocket(connectionString);\n              client = Stomp.over(ws);\n              client.heartbeat.outgoing = 10000;\n              client.heartbeat.incoming = 10000;\n              client.debug = null;\n            }\n            const headers = merge(this._connectionHeaders, {\n              login: connectionParams.deviceId || connectionParams.client,\n              passcode: connectionParams.secret,\n              host: connectionParams.vhost\n            });\n            client.connect(headers, () => {\n              this._stompConnection = client;\n              resolve(this._stompConnection);\n            }, (err) => {\n              reject(err);\n            });\n          } catch (reason) {\n            reject(reason);\n          }\n        }\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Generate the subscription string for a specific channel\n   *\n   * @private\n   * @param {String} type - resource type on which subscribe or publish [exchange/queue]\n   * @param {String} channel - channel name on which you want to publish a message\n   * @return a string that represents the topic name for that channel\n   */\n  _subcriptionFor(type, channel) {\n    return `/${type}/${this.deviceId()}.${channel}`;\n  }\n\n  /**\n   * Generate the destination string for a specific channel\n   *\n   * @private\n   * @param {String} type - resource type on which subscribe or publish [exchange/queue]\n   * @param {String} channel - channel name on which you want to publish a message\n   * @return a string that represents the topic name for that channel\n   */\n  _destinationFor(type, channel) {\n    return `/${type}/${this.deviceId()}/${this.deviceId()}.${channel}`;\n  }\n\n  /**\n   * Check if the SDK have to automatically ack messages\n   * By default STOMP messages are acked by the server\n   * they need to be acked if client subscribes with { ack: 'client' } option\n   *\n   * @private\n   * @param {String} ack - the ack type, it should be 'client' or null\n   * @return boolean - true if messages have to be autoacked, false otherwise\n   */\n  _autoAck(ack) {\n    if (ack) {\n      if (!_.includes(CONFIG[this._protocol].ackTypes, ack)) {\n        console.error('Wrong acknowledge type'); // eslint-disable-line no-console\n      }\n      switch (ack) {\n        case 'client':\n          return false;\n        default:\n          return true;\n      }\n    }\n    return false;\n  }\n\n}\n\nexport default StompClient;\n"],"sourceRoot":"/Users/gfoiani/Dev/work/spacebunny/sdk/node/src"}