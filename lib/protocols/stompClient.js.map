{"version":3,"sources":["protocols/stompClient.js"],"names":["require","CONFIG","StompClient","opts","_stompConnection","undefined","_subscription","process","_protocol","stompOpts","stomp","webStompOpts","webStomp","_webSocketOpts","webSocket","_connectionHeaders","connection","headers","_connectionOpts","_existingQueuePrefix","existingQueuePrefix","callback","Promise","resolve","reject","connect","then","client","topic","_subcriptionFor","_inboxTopic","subscriptionCallback","message","stompMessage","StompMessage","_deviceId","ackNeeded","_autoAck","ack","blackListed","nack","_parseContent","body","subscribe","catch","reason","channel","destination","_destinationFor","send","_encapsulateContent","isConnected","Error","unsubscribe","disconnect","emit","getEndpointConfigs","endpointConfigs","connectionParams","_tls","Stomp","overTCP","host","protocols","tlsPort","_tlsOpts","port","protocol","tls","connectionString","endpoint","ws","WebSocket","over","heartbeat","outgoing","incoming","debug","login","deviceId","passcode","secret","vhost","err","str","on","connected","type","ackTypes","console","error","SpaceBunny"],"mappings":"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","file":"stompClient.js","sourcesContent":["/**\n * A module that exports an StompClient client\n * which inherits from the SpaceBunny base client\n * @module StompClient\n */\n\n// Import some helpers modules\nimport merge from 'merge';\nimport Promise from 'bluebird';\nimport _ from 'lodash';\n\n// Import stomp library\nimport Stomp from 'stompjs';\n\n// Import SpaceBunny main module from which StompClient inherits\nimport SpaceBunny from '../spacebunny';\nimport StompMessage from '../messages/stompMessage';\n\nconst { CONFIG } = require('../../config/constants');\n\nclass StompClient extends SpaceBunny {\n  /**\n   * @constructor\n   * @param {Object} opts - options must contain Device-Key or connection options\n   * (deviceId and secret) for devices.\n   */\n  constructor(opts) {\n    super(opts);\n    this._stompConnection = undefined;\n    this._subscription = undefined;\n    if (typeof process === 'object' && `${process}` === '[object process]') {\n      this._protocol = 'stomp';\n    } else {\n      this._protocol = 'webStomp';\n    }\n    const stompOpts = CONFIG.stomp;\n    const webStompOpts = CONFIG.webStomp;\n    this._webSocketOpts = webStompOpts.webSocket;\n    this._connectionHeaders = stompOpts.connection.headers;\n    this._connectionOpts = stompOpts.connection.opts;\n    this._existingQueuePrefix = stompOpts.existingQueuePrefix;\n  }\n\n  /**\n   * Subscribe to input channel\n   *\n   * @param {function} callback - function called every time a message is received\n   * passing the current message as argument\n   * @param {Object} options - subscription options\n   * @return promise containing the result of the subscription\n   */\n  onReceive(callback, opts) {\n    opts = merge({}, opts);\n    // subscribe for input messages\n    return new Promise((resolve, reject) => {\n      this.connect().then((client) => {\n        const topic = this._subcriptionFor(this._existingQueuePrefix, this._inboxTopic);\n        const subscriptionCallback = (message) => {\n          // Create message object\n          const stompMessage = new StompMessage(message, this._deviceId, opts);\n          const ackNeeded = this._autoAck(opts.ack);\n          // Check if should be accepted or not\n          if (stompMessage.blackListed()) {\n            if (ackNeeded) { message.nack(); }\n            return;\n          }\n          // Call message callback\n          callback(this._parseContent(stompMessage.body), stompMessage.headers);\n          // Check if ACK is needed\n          if (ackNeeded) { message.ack(); }\n        };\n        this._subscription = client.subscribe(topic, subscriptionCallback);\n        resolve(true);\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Publish a message on a specific channel\n   *\n   * @param {String} channel - channel name on which you want to publish a message\n   * @param {Object} message - the message payload\n   * @param {Object} opts - publication options\n   * @return a promise containing the result of the operation\n   */\n  publish(channel, message, opts) {\n    opts = merge({}, opts);\n    // Publish message\n    return new Promise((resolve, reject) => {\n      this.connect().then((client) => {\n        const destination = this._destinationFor('exchange', channel);\n        client.send(destination, this._connectionHeaders, this._encapsulateContent(message));\n        resolve(true);\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Destroy the connection between the stomp client and broker\n   *\n   * @return a promise containing the result of the operation\n   */\n  disconnect() {\n    return new Promise((resolve, reject) => {\n      if (!this.isConnected()) {\n        reject(new Error('Invalid connection'));\n      } else {\n        if (this._subscription !== undefined) {\n          this._subscription.unsubscribe();\n        }\n        this._stompConnection.disconnect(() => {\n          this.emit('disconnect');\n          this._stompConnection = undefined;\n          resolve(true);\n        }).catch((reason) => {\n          this._stompConnection = undefined;\n          reject(reason);\n        });\n      }\n    });\n  }\n\n  /**\n   * Establish an stomp connection with the broker.\n   * If a connection already exists, returns the current connection\n   *\n   * @param {Object} opts - connection options\n   * @return a promise containing current connection\n   */\n  connect(opts = {}) {\n    opts = merge(this._connectionOpts, opts);\n    return new Promise((resolve, reject) => {\n      this.getEndpointConfigs().then((endpointConfigs) => {\n        const connectionParams = endpointConfigs.connection;\n        if (this.isConnected()) {\n          resolve(this._stompConnection);\n        } else {\n          try {\n            let client;\n            if (typeof process === 'object' && `${process}` === '[object process]') {\n              // code is runnning in nodejs: STOMP uses TCP sockets\n              if (this._tls) {\n                client = Stomp.overTCP(connectionParams.host, connectionParams.protocols.stomp.tlsPort, this._tlsOpts);\n              } else {\n                client = Stomp.overTCP(connectionParams.host, connectionParams.protocols.stomp.port);\n              }\n            } else {\n              // code is runnning in a browser: web STOMP uses Web sockets\n              const protocol = (this._tls) ? this._webSocketOpts.tls.protocol : this._webSocketOpts.protocol;\n              const port = (this._tls)\n                ? connectionParams.protocols.webStomp.tlsPort : connectionParams.protocols.webStomp.port;\n              const connectionString = `${protocol}://${connectionParams.host}:${port}/${this._webSocketOpts.endpoint}`;\n              const ws = new WebSocket(connectionString);\n              client = Stomp.over(ws);\n              client.heartbeat.outgoing = 10000;\n              client.heartbeat.incoming = 10000;\n              client.debug = null;\n            }\n            const headers = merge(this._connectionHeaders, {\n              login: connectionParams.deviceId || connectionParams.client,\n              passcode: connectionParams.secret,\n              host: connectionParams.vhost\n            });\n            client.connect(headers, () => {\n              this._stompConnection = client;\n              this.emit('connect');\n              resolve(this._stompConnection);\n            }, (err) => {\n              this.emit('error', err.body);\n              // this._stompConnection = undefined;\n              // reject(err.body);\n            });\n            client.debug = (str) => {\n              this.emit('debug', str);\n            };\n            this.on('error', () => {});\n          } catch (reason) {\n            reject(reason);\n          }\n        }\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  isConnected() {\n    return (this._stompConnection !== undefined && this._stompConnection.connected);\n  }\n\n  // ------------ PRIVATE METHODS -------------------\n\n  /**\n   * Generate the subscription string for a specific channel\n   *\n   * @private\n   * @param {String} type - resource type on which subscribe or publish [exchange/queue]\n   * @param {String} channel - channel name on which you want to publish a message\n   * @return a string that represents the topic name for that channel\n   */\n  _subcriptionFor(type, channel) {\n    return `/${type}/${this.deviceId()}.${channel}`;\n  }\n\n  /**\n   * Generate the destination string for a specific channel\n   *\n   * @private\n   * @param {String} type - resource type on which subscribe or publish [exchange/queue]\n   * @param {String} channel - channel name on which you want to publish a message\n   * @return a string that represents the topic name for that channel\n   */\n  _destinationFor(type, channel) {\n    return `/${type}/${this.deviceId()}/${this.deviceId()}.${channel}`;\n  }\n\n  /**\n   * Check if the SDK have to automatically ack messages\n   * By default STOMP messages are acked by the server\n   * they need to be acked if client subscribes with { ack: 'client' } option\n   *\n   * @private\n   * @param {String} ack - the ack type, it should be 'client' or null\n   * @return boolean - true if messages have to be autoacked, false otherwise\n   */\n  _autoAck(ack) {\n    if (ack) {\n      if (!_.includes(CONFIG[this._protocol].ackTypes, ack)) {\n        console.error('Wrong acknowledge type'); // eslint-disable-line no-console\n      }\n      switch (ack) {\n        case 'client':\n          return false;\n        default:\n          return true;\n      }\n    }\n    return false;\n  }\n}\n\nexport default StompClient;\n"],"sourceRoot":"../src"}