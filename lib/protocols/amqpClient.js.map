{"version":3,"sources":["protocols/amqpClient.js"],"names":["require","CONFIG","AmqpClient","opts","_amqpConnection","undefined","_amqpChannels","amqpOptions","amqp","_protocol","protocol","_tlsProtocol","tls","_inputQueueArgs","inputQueueArgs","_deviceExchangeArgs","deviceExchangeArgs","_subscribeArgs","subscribeArgs","_publishArgs","publishArgs","_connectionOpts","connectionOpts","callback","Promise","resolve","reject","localOpts","noAck","ack","_createChannel","then","ch","all","checkQueue","deviceId","_inboxTopic","consume","message","amqpMessage","AmqpMessage","receiverId","_deviceId","subscriptionOpts","channel","ackNeeded","_autoAck","blackListed","nack","allUpTo","requeue","res","catch","reason","routingKey","topic","promises","checkExchange","publish","_routingKeyFor","Buffer","from","withConfirm","push","waitForConfirms","Error","close","emit","getEndpointConfigs","endpointConfigs","connectionParams","connection","isConnected","connectionString","_tls","client","secret","host","protocols","tlsPort","vhost","replace","_tlsOpts","port","connect","conn","on","err","console","warn","channelName","createConfirmChannel","createChannel","error","params","messageRoutingKey","ackTypes","SpaceBunny"],"mappings":"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","file":"amqpClient.js","sourcesContent":["/**\n * A module that exports an AmqpClient client\n * which inherits from the SpaceBunny base client\n * @module AmqpClient\n */\n\n// Import some helpers modules\nimport Promise from 'bluebird';\nimport _ from 'lodash';\n\n// Import amqplib\nimport amqp from 'amqplib';\n\n// Import SpaceBunny main module from which AmqpClient inherits\nimport SpaceBunny from '../spacebunny';\nimport AmqpMessage from '../messages/amqpMessage';\nimport { encapsulateContent } from '../utils';\n\nconst { CONFIG } = require('../../config/constants');\n\nclass AmqpClient extends SpaceBunny {\n  /**\n   * @constructor\n   * @param {Object} opts - options must contain Device-Key or connection options\n   * (deviceId and secret) for devices.\n   */\n  constructor(opts = {}) {\n    super(opts);\n    this._amqpConnection = undefined;\n    this._amqpChannels = {};\n    const amqpOptions = CONFIG.amqp;\n    this._protocol = amqpOptions.protocol;\n    this._tlsProtocol = amqpOptions.tls.protocol;\n    this._inputQueueArgs = amqpOptions.inputQueueArgs;\n    this._deviceExchangeArgs = amqpOptions.deviceExchangeArgs;\n    this._subscribeArgs = amqpOptions.subscribeArgs;\n    this._publishArgs = amqpOptions.publishArgs;\n    this._connectionOpts = amqpOptions.connectionOpts;\n  }\n\n  /**\n   * Subscribe to input channel\n   *\n   * @param {function} callback - function called every time a message is received\n   * passing the current message as argument\n   * @param {Object} options - subscription options\n   * @return promise containing the result of the subscription\n   */\n  onReceive(callback, opts = {}) {\n    // Receive messages from imput queue\n    return new Promise((resolve, reject) => {\n      let localOpts = _.cloneDeep(opts);\n      localOpts = _.merge(_.cloneDeep(this._subscribeArgs), localOpts);\n      localOpts.noAck = (localOpts.ack === null);\n      this._createChannel('input', localOpts).then((ch) => {\n        return Promise.all([\n          ch.checkQueue(`${this.deviceId()}.${this._inboxTopic}`, this._inputQueueArgs),\n          ch.consume(`${this.deviceId()}.${this._inboxTopic}`, (message) => {\n            // Create message object\n            const amqpMessage = new AmqpMessage({\n              message,\n              receiverId: this._deviceId,\n              subscriptionOpts: localOpts,\n              channel: ch\n            });\n            const ackNeeded = this._autoAck(localOpts.ack);\n            // Check if should be accepted or not\n            if (amqpMessage.blackListed()) {\n              if (ackNeeded) { ch.nack(message, localOpts.allUpTo, localOpts.requeue); }\n              return;\n            }\n            // Call message callback\n            callback(amqpMessage);\n            // Check if ACK is needed\n            if (ackNeeded) { ch.ack(message, localOpts.allUpTo); }\n          }, localOpts)\n        ]);\n      }).then((res) => {\n        resolve(res);\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Publish a message on a specific channel\n   *\n   * @param {String} channel - channel name on which you want to publish a message\n   * @param {Object} message - the message payload\n   * @param {Object} opts - publication options\n   * @return promise containing the result of the subscription\n   */\n  publish(channel, message, opts = {}) {\n    return new Promise((resolve, reject) => {\n      let localOpts = _.cloneDeep(opts);\n      localOpts = _.merge(_.cloneDeep(this._publishArgs), localOpts);\n      this._createChannel('output', localOpts).then((ch) => {\n        const { routingKey = undefined, topic = undefined } = localOpts;\n        const promises = [\n          ch.checkExchange(this.deviceId()),\n          ch.publish(this.deviceId(), this._routingKeyFor({ channel, routingKey, topic }),\n            Buffer.from(encapsulateContent(message)), localOpts)\n        ];\n        if (localOpts.withConfirm === true) {\n          promises.push(ch.waitForConfirms());\n        }\n        return Promise.all(promises);\n      }).then((res) => {\n        resolve(res);\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Destroy the connection between the amqp client and broker\n   *\n   * @return a promise containing the result of the operation\n   */\n  disconnect() {\n    return new Promise((resolve, reject) => {\n      if (this._amqpConnection === undefined) {\n        reject(new Error('Not Connected'));\n      } else {\n        this._amqpConnection.close().then(() => {\n          this._amqpConnection = undefined;\n          this._amqpChannels = {};\n          this.emit('disconnect');\n          resolve(true);\n        }).catch((reason) => {\n          reject(reason);\n        });\n      }\n    });\n  }\n\n  /**\n   * Establish an amqp connection with the broker\n   * using configurations retrieved from the endpoint.\n   * If the connnection already exists, returns the current connnection\n   *\n   * @return a promise containing current connection\n   */\n  connect(opts = {}) {\n    return new Promise((resolve, reject) => {\n      let connectionOpts = _.cloneDeep(opts);\n      connectionOpts = _.merge(_.cloneDeep(this._connectionOpts), connectionOpts);\n      this.getEndpointConfigs().then((endpointConfigs) => {\n        const connectionParams = endpointConfigs.connection;\n        if (this.isConnected()) {\n          resolve(this._amqpConnection);\n          return undefined;\n        } else {\n          let connectionString = '';\n          if (this._tls) {\n            connectionString = `${this._tlsProtocol}://${connectionParams.deviceId || connectionParams.client}:`\n              + `${connectionParams.secret}@${connectionParams.host}:`\n              + `${connectionParams.protocols.amqp.tlsPort}/${connectionParams.vhost.replace('/', '%2f')}`;\n            connectionOpts = _.merge(connectionOpts, this._tlsOpts);\n          } else {\n            connectionString = `${this._protocol}://${connectionParams.deviceId || connectionParams.client}:`\n              + `${connectionParams.secret}@${connectionParams.host}:`\n              + `${connectionParams.protocols.amqp.port}/${connectionParams.vhost.replace('/', '%2f')}`;\n          }\n          return amqp.connect(connectionString, connectionOpts).then((conn) => {\n            conn.on('error', (err) => {\n              this.emit('error', err);\n              reject(err);\n            });\n            conn.on('close', (err) => {\n              this.emit('close', err);\n              this._amqpConnection = undefined;\n            });\n            conn.on('blocked', (reason) => {\n              this.emit('blocked', reason);\n              console.warn(reason); // eslint-disable-line no-console\n            });\n            conn.on('unblocked', (reason) => {\n              this.emit('unblocked', reason);\n              console.warn(reason); // eslint-disable-line no-console\n            });\n            this._amqpConnection = conn;\n            this.on('error', () => {});\n            this.emit('connect');\n            resolve(this._amqpConnection);\n          }).catch((reason) => {\n            reject(reason);\n          });\n        }\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  isConnected() {\n    return (this._amqpConnection !== undefined);\n  }\n\n  // ------------ PRIVATE METHODS -------------------\n\n  /**\n   * Creates a channel on current connection\n   *\n   * @private\n   * @param {String} channelName - indicates the channel name\n   * @param {Object} opts - channel options\n   * @return a promise containing the current channel\n   */\n  _createChannel(channelName, opts = {}) {\n    channelName = `${channelName}${(opts.withConfirm === true) ? 'WithConfirm' : ''}`;\n    return new Promise((resolve, reject) => {\n      if (this._amqpChannels[channelName]) {\n        resolve(this._amqpChannels[channelName]);\n      } else {\n        this.connect().then((conn) => {\n          if (opts.withConfirm === true) {\n            return conn.createConfirmChannel();\n          } else {\n            return conn.createChannel();\n          }\n        }).then((ch) => {\n          this._amqpChannels[channelName] = ch;\n          this._amqpChannels[channelName].on('error', (err) => {\n            console.error(err); // eslint-disable-line no-console\n            this._amqpChannels[channelName] = undefined;\n          });\n          this._amqpChannels[channelName].on('close', (err) => {\n            console.error(err); // eslint-disable-line no-console\n            this._amqpChannels[channelName] = undefined;\n          });\n          resolve(ch);\n        }).catch((reason) => {\n          reject(reason);\n        });\n      }\n    });\n  }\n\n  /**\n   * Close a channel on current connection\n   *\n   * @private\n   * @param {String} channelName - indicates if the channel is input or output\n   * @return a promise containing the result of the operation\n   */\n  _closeChannel(channelName, opts = {}) {\n    channelName = `${channelName}${(opts.withConfirm === true) ? 'WithConfirm' : ''}`;\n    return new Promise((resolve, reject) => {\n      const ch = this._amqpChannels[channelName];\n      if (ch === undefined) {\n        reject(new Error('Invalid Channel Object'));\n      } else {\n        ch.close().then(() => {\n          this._amqpChannels[channelName] = undefined;\n          resolve(true);\n        }).catch((reason) => {\n          reject(reason);\n        });\n      }\n    });\n  }\n\n  /**\n   * Generate the routing key for a specific channel\n   *\n   * @private\n   * @param {Object} params - params\n   * @return a string that represents the routing key for that channel\n   */\n  _routingKeyFor(params) {\n    const { channel = undefined, routingKey = undefined, topic = undefined } = params;\n    if (routingKey) {\n      return routingKey;\n    } else {\n      let messageRoutingKey = this.deviceId();\n      if (!_.isEmpty(channel)) {\n        messageRoutingKey += `.${channel}`;\n      }\n      if (!_.isEmpty(topic)) {\n        messageRoutingKey += `.${topic}`;\n      }\n      return messageRoutingKey;\n    }\n  }\n\n  /**\n   * Check if the SDK have to automatically ack messages\n   *\n   * @private\n   * @param {String} ack - the ack type, it should be 'manual' or 'auto'\n   * @return boolean - true if messages have to be autoacked, false otherwise\n   */\n  _autoAck(ack) {\n    if (ack) {\n      if (!_.includes(CONFIG[this._protocol].ackTypes, ack)) {\n        console.error('Wrong acknowledge type'); // eslint-disable-line no-console\n      }\n      switch (ack) {\n        case 'auto':\n          return true;\n        default:\n          return false;\n      }\n    }\n    return true;\n  }\n}\n\nexport default AmqpClient;\n"],"sourceRoot":"../src"}