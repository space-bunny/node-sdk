{"version":3,"sources":["protocols/amqpClient.js"],"names":[],"mappings":"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","file":"protocols/amqpClient.js","sourcesContent":["/**\n * A module that exports an AmqpClient client\n * which inherits from the SpaceBunny base client\n * @module AmqpClient\n */\n\n// Import some helpers modules\nimport merge from 'merge';\nimport Promise from 'bluebird';\nimport when from 'when';\nimport _ from 'lodash';\n\n// Import amqplib\nimport amqp from 'amqplib';\n\n// Import SpaceBunny main module from which AmqpClient inherits\nimport SpaceBunny from '../spacebunny';\nimport AmqpMessage from '../messages/amqpMessage';\nconst CONFIG = require('../../config/constants').CONFIG;\n\nclass AmqpClient extends SpaceBunny {\n\n  /**\n   * @constructor\n   * @param {Object} opts - options must contain Device-Key or connection options\n   * (deviceId and secret) for devices.\n   */\n  constructor(opts) {\n    super(opts);\n    this._amqpConnection = undefined;\n    this._amqpChannels = {};\n    const amqpOptions = CONFIG.amqp;\n    this._protocol = amqpOptions.protocol;\n    this._tlsProtocol = amqpOptions.tls.protocol;\n    this._inputQueueArgs = amqpOptions.inputQueueArgs;\n    this._deviceExchangeArgs = amqpOptions.deviceExchangeArgs;\n    this._subscribeArgs = amqpOptions.subscribeArgs;\n    this._publishArgs = amqpOptions.publishArgs;\n    this._connectionOpts = amqpOptions.connectionOpts;\n  }\n\n  /**\n   * Subscribe to input channel\n   *\n   * @param {function} callback - function called every time a message is received\n   * passing the current message as argument\n   * @param {Object} options - subscription options\n   * @return promise containing the result of the subscription\n   */\n  onReceive(callback, opts) {\n    opts = merge(this._subscribeArgs, opts);\n    opts.noAck = (opts.ack === null);\n    // Receive messages from imput queue\n    return new Promise((resolve, reject) => {\n      this._createChannel('input', opts).then((ch) => {\n        return when.all([\n          ch.checkQueue(`${this.deviceId()}.${this._inboxTopic}`, this._inputQueueArgs),\n          ch.consume(`${this.deviceId()}.${this._inboxTopic}`, (message) => {\n            // Create message object\n            const amqpMessage = new AmqpMessage(message, this._deviceId, opts);\n            const ackNeeded = this._autoAck(opts.ack);\n            // Check if should be accepted or not\n            if (amqpMessage.blackListed()) {\n              if (ackNeeded) { ch.nack(message, opts.allUpTo, opts.requeue); }\n              return;\n            }\n            // Call message callback\n            callback(this._parseContent(amqpMessage.content), amqpMessage.fields, amqpMessage.properties);\n            // Check if ACK is needed\n            if (ackNeeded) { ch.ack(message, opts.allUpTo); }\n          }, opts)\n        ]);\n      }).then((res) => {\n        resolve(res);\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Publish a message on a specific channel\n   *\n   * @param {String} channel - channel name on which you want to publish a message\n   * @param {Object} message - the message payload\n   * @param {Object} opts - publication options\n   * @return promise containing the result of the subscription\n   */\n  publish(channel, message, opts = {}) {\n    opts = merge(this._publishArgs, opts);\n    return new Promise((resolve, reject) => {\n      this._createChannel('output', opts).then((ch) => {\n        const bufferedMessage = new Buffer(this._encapsulateContent(message));\n        const promises = [\n          ch.checkExchange(this.deviceId()),\n          ch.publish(this.deviceId(), this._routingKeyFor(channel), bufferedMessage, opts)\n        ];\n        if (opts.withConfirm === true) {\n          promises.push(ch.waitForConfirms());\n        }\n        return when.all(promises);\n      }).then((res) => {\n        resolve(res);\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  /**\n   * Destroy the connection between the amqp client and broker\n   *\n   * @return a promise containing the result of the operation\n   */\n  disconnect() {\n    return new Promise((resolve, reject) => {\n      if (this._amqpConnection === undefined) {\n        reject('Not Connected');\n      } else {\n        this._amqpConnection.close().then(() => {\n          this._amqpConnection = undefined;\n          resolve(true);\n        }).catch((reason) => {\n          reject(reason);\n        });\n      }\n    });\n  }\n\n  /**\n   * Establish an amqp connection with the broker\n   * using configurations retrieved from the endpoint.\n   * If the connnection already exists, returns the current connnection\n   *\n   * @return a promise containing current connection\n   */\n  connect(opts = {}) {\n    let connectionOpts = merge(this._connectionOpts, opts);\n\n    return new Promise((resolve, reject) => {\n      this.getEndpointConfigs().then((endpointConfigs) => {\n        const connectionParams = endpointConfigs.connection;\n        if (this._amqpConnection !== undefined) {\n          resolve(this._amqpConnection);\n        } else {\n          let connectionString = '';\n          if (this._tls) {\n            connectionString = `${this._tlsProtocol}://${connectionParams.deviceId || connectionParams.client}:` +\n              `${connectionParams.secret}@${connectionParams.host}:` +\n              `${connectionParams.protocols.amqp.tlsPort}/${connectionParams.vhost.replace('/', '%2f')}`;\n            connectionOpts = merge(connectionOpts, this._tlsOpts);\n          } else {\n            connectionString = `${this._protocol}://${connectionParams.deviceId || connectionParams.client}:` +\n              `${connectionParams.secret}@${connectionParams.host}:` +\n              `${connectionParams.protocols.amqp.port}/${connectionParams.vhost.replace('/', '%2f')}`;\n          }\n          amqp.connect(connectionString, connectionOpts).then((conn) => {\n            conn.on('error', (err) => {\n              reject(err);\n            });\n            conn.on('blocked', (reason) => {\n              console.warn(reason); // eslint-disable-line no-console\n            });\n            conn.on('unblocked', (reason) => {\n              console.warn(reason); // eslint-disable-line no-console\n            });\n            this._amqpConnection = conn;\n            resolve(this._amqpConnection);\n          }).catch((reason) => {\n            reject(reason);\n          });\n        }\n      }).catch((reason) => {\n        reject(reason);\n      });\n    });\n  }\n\n  // ------------ PRIVATE METHODS -------------------\n\n  /**\n   * Creates a channel on current connection\n   *\n   * @private\n   * @param {String} channelName - indicates the channel name\n   * @param {Object} opts - channel options\n   * @return a promise containing the current channel\n   */\n  _createChannel(channelName, opts = {}) {\n    channelName = `${channelName}${(opts.withConfirm === true) ? 'WithConfirm' : ''}`;\n    return new Promise((resolve, reject) => {\n      if (this._amqpChannels[channelName]) {\n        resolve(this._amqpChannels[channelName]);\n      } else {\n        this.connect().then((conn) => {\n          if (opts.withConfirm === true) {\n            return conn.createConfirmChannel();\n          } else {\n            return conn.createChannel();\n          }\n        }).then((ch) => {\n          this._amqpChannels[channelName] = ch;\n          resolve(ch);\n        }).catch((reason) => {\n          reject(reason);\n        });\n      }\n    });\n  }\n\n  /**\n   * Close a channel on current connection\n   *\n   * @private\n   * @param {String} channelName - indicates if the channel is input or output\n   * @return a promise containing the result of the operation\n   */\n  _closeChannel(channelName, opts = {}) {\n    channelName = `${channelName}${(opts.withConfirm === true) ? 'WithConfirm' : ''}`;\n    return new Promise((resolve, reject) => {\n      const ch = this._amqpChannels[channelName];\n      if (ch === undefined) {\n        reject('Invalid Channel Object');\n      } else {\n        ch.close().then(() => {\n          this._amqpChannels[channelName] = undefined;\n          resolve(true);\n        }).catch((reason) => {\n          reject(reason);\n        });\n      }\n    });\n  }\n\n  /**\n   * Generate the routing key for a specific channel\n   *\n   * @private\n   * @param {String} channel - channel name on which you want to publish a message\n   * @return a string that represents the routing key for that channel\n   */\n  _routingKeyFor(channel) {\n    return `${this.deviceId()}.${channel}`;\n  }\n\n  /**\n   * Check if the SDK have to automatically ack messages\n   *\n   * @private\n   * @param {String} ack - the ack type, it should be 'manual' or 'auto'\n   * @return boolean - true if messages have to be autoacked, false otherwise\n   */\n  _autoAck(ack) {\n    if (ack) {\n      if (!_.includes(CONFIG[this._protocol].ackTypes, ack)) {\n        console.error('Wrong acknowledge type'); // eslint-disable-line no-console\n      }\n      switch (ack) {\n        case 'auto':\n          return true;\n        default:\n          return false;\n      }\n    }\n    return true;\n  }\n\n}\n\nexport default AmqpClient;\n"],"sourceRoot":"/Users/gfoiani/Dev/work/spacebunny/sdk/node/src"}